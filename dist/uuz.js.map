{"version":3,"file":"uuz.js","sources":["../src/utils/base.js","../src/core/h.js","../src/core/scheduler.js","../src/core/reactive.js","../src/core/dom.js","../src/core/diff.js","../src/core/renderer.js"],"sourcesContent":["export const isArr = Array.isArray;\r\nexport const isFn = (fn) => typeof fn === 'function';\r\nexport const isStr = (v) => typeof v === 'string';\r\nexport const isObject = (val) => val !== null && typeof val === 'object';\r\nexport const isText = (v) => typeof v === 'string' || typeof v === 'number';\r\n\r\nexport const isStuff = (v) => v !== null && v !== false && v !== true;\r\n\r\nexport const Fragment = Symbol( 'Fragment' );\r\nexport const Text = Symbol( 'Text' );\r\nexport const Comment = Symbol( 'Comment' );\r\nexport const Static = Symbol( 'Static' );\r\n\r\nexport const ShapeFlags = {\r\n  ELEMENT: 1,\r\n  STATEFUL_COMPONENT: 1 << 2,\r\n  TEXT_CHILDREN: 1 << 3,\r\n  ARRAY_CHILDREN: 1 << 4,\r\n}\r\n\r\nexport const getShapeFlag = (type) => {\r\n  return typeof type === \"string\"\r\n    ? ShapeFlags.ELEMENT\r\n    : ShapeFlags.STATEFUL_COMPONENT;\r\n}","import { ShapeFlags, getShapeFlag, Text, isObject } from \"../utils/base.js\";\r\n\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n\r\nfunction createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n\tconst vnode = {\r\n\t\tel: null,\r\n\t\tcomponent: null,\r\n\t\tkey: (props && props.key) || null,\r\n\t\ttype,\r\n\t\tprops,\r\n\t\tchildren,\r\n\t\tshapeFlag: getShapeFlag(type),\r\n\t};\r\n\r\n\tif (Array.isArray(children)) {\r\n\t\tvnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN;\r\n\t} else if (typeof children === \"string\") {\r\n\t\tvnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN;\r\n\t}\r\n\treturn vnode;\r\n}\r\n\r\n// TODO:\r\nconst openBlock = (disableTracking = false) => {\r\n\tblockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\n\r\n// TODO:\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n\t /* isBlock: prevent a block from tracking itself */\r\n\tconst vnode = createVNode(type, props, children, patchFlag, dynamicProps, true);\r\n\t// save current block children on the block vnode\r\n\tvnode.dynamicChildren = currentBlock || EMPTY_ARR;\r\n\t// close block\r\n\tblockStack.pop();\r\n\tcurrentBlock = blockStack[blockStack.length - 1] || null;\r\n\t// a block is always going to be patched, so track it as a child of its\r\n\t// parent block\r\n\tif (currentBlock) {\r\n\t\tcurrentBlock.push(vnode);\r\n\t}\r\n\treturn vnode;\r\n}\r\n\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n  return createVNode(Text, null, text, flag);\r\n}\r\n\r\nconst toDisplayString = (val) => {\r\n  return val == null\r\n    ? ''\r\n    : isObject(val)\r\n      ? JSON.stringify(val, replacer, 2)\r\n      : String(val);\r\n};\r\n\r\nexport {\r\n\tcreateVNode,\r\n\topenBlock,\r\n\tcreateBlock,\r\n\tcreateTextVNode,\r\n\ttoDisplayString\r\n}\r\n","const queue = [];\r\n\r\nconst p = Promise.resolve();\r\nlet isFlushPending = false;\r\n\r\nfunction nextTick(fn) {\r\n  return fn ? p.then(fn) : p;\r\n}\r\n\r\nfunction queueJob(job) {\r\n  if (!queue.includes(job)) {\r\n    queue.push(job);\r\n    // 执行所有的 job\r\n    queueFlush();\r\n  }\r\n}\r\n\r\nfunction queueFlush() {\r\n  if (isFlushPending) return;\r\n  isFlushPending = true;\r\n  nextTick(flushJobs);\r\n}\r\n\r\nfunction flushJobs() {\r\n  isFlushPending = false;\r\n  let job;\r\n  while ((job = queue.shift())) {\r\n    if (job) {\r\n      job();\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  nextTick,\r\n  queueJob\r\n}\r\n","\r\nlet targetMap = new WeakMap();\r\nlet activeEffect;\r\n\r\nfunction effect(fn, options = {}) {\r\n  const _effect = function(...args) {\r\n    activeEffect = _effect;\r\n    return fn(...args);\r\n  };\r\n  /* computed相关 */\r\n  if (!options.lazy) {\r\n    _effect();\r\n  }\r\n  /* \r\n    options 比如：scheduler\r\n  */\r\n  _effect.options = options;\r\n  return _effect;\r\n}\r\n\r\nfunction track(target, key) {\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n\t\ttargetMap.set(target, (depsMap = new Map()));\r\n  }\r\n  let dep = depsMap.get(key);\r\n\tif (!dep) {\r\n    depsMap.set(key, (dep = new Set()));\r\n  }\r\n  if (!dep.has(activeEffect)) {\r\n    dep.add(activeEffect);\r\n\t}\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target);\r\n  if (!depsMap) return;\r\n  const effects = new Set()\r\n  depsMap.get(key).forEach(e => effects.add(e))\r\n  effects.forEach(e => scheduleRun(e))\r\n}\r\n\r\nfunction scheduleRun(effect) {\r\n  if (effect.options.scheduler !== void 0) {\r\n    effect.options.scheduler(effect);\r\n  } else {\r\n    effect();\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  return new Proxy(target, {\r\n    get(target, prop) {\r\n      track(target, prop);\r\n      return Reflect.get(target, prop);\r\n    },\r\n    set(target, prop, newVal) {\r\n      Reflect.set(target, prop, newVal);\r\n      trigger(target, prop);\r\n      /* \r\n        必须 return true;\r\n        否则会产生警告 'set' on proxy: trap returned falsish for property\r\n      */\r\n      return true;\r\n    }\r\n  })\r\n}\r\n\r\nfunction ref(target) {\r\n  let value = target\r\n\r\n  const obj = {\r\n    get value() {\r\n      track(obj, 'value');\r\n      return value;\r\n    },\r\n    set value(newVal) {\r\n      if (newVal !== value) {\r\n        value = newVal;\r\n        trigger(obj, 'value');\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nfunction computed(fn) {\r\n  let dirty = true;\r\n  let value;\r\n  let _computed;\r\n\r\n  const runner = effect(fn, {\r\n    lazy: true,\r\n    scheduler: (e) => {\r\n      if (!dirty) {\r\n        dirty = true;\r\n        trigger(_computed, 'value');\r\n      }\r\n    }\r\n  });\r\n  \r\n  _computed = {\r\n    get value() {\r\n      if (dirty) {\r\n        value = runner();\r\n        dirty = false;\r\n      }\r\n      track(_computed, 'value');\r\n      return value;\r\n    }\r\n  }\r\n  return _computed;\r\n}\r\n\r\n\r\nexport {\r\n  reactive,\r\n  ref,\r\n  effect,\r\n  computed\r\n}","function hostCreateElement(type) {\r\n  const element = document.createElement(type);\r\n  return element;\r\n}\r\n\r\nfunction hostSetElementText(el, text) {\r\n  el.innerText = text;\r\n}\r\n\r\nfunction hostPatchProp(el, key, preValue, nextValue) {\r\n  // console.log(el, key, preValue, nextValue, 'el, key, preValue, nextValue')\r\n  // TODO: 属性移除和比较\r\n  switch (key) {\r\n    case \"id\":\r\n    case \"tId\":\r\n      if (nextValue === null || nextValue === undefined) {\r\n        el.removeAttribute(key);\r\n      } else {\r\n        el.setAttribute(key, nextValue);\r\n      }\r\n      break;\r\n    case \"class\":\r\n      el.setAttribute(\"class\", nextValue);\r\n      break;\r\n    // case \"onclick\":\r\n    case \"onClick\":\r\n      // todo\r\n      // 先临时实现 click 事件\r\n      // 后面应该用 directive 来处理\r\n      el.addEventListener(\"click\", nextValue);\r\n      break;\r\n  }\r\n}\r\n\r\nfunction hostInsert(child, parent, anchor=null) {\r\n  if (anchor) {\r\n    parent.insertBefore(child,anchor);\r\n  } else {\r\n    parent.appendChild(child);\r\n  }\r\n}\r\n\r\nfunction hostRemove(child) {\r\n  const parent = child.parentNode;\r\n  if (parent) {\r\n    parent.removeChild(child);\r\n  }\r\n}\r\n\r\nexport {\r\n  hostCreateElement,\r\n  hostSetElementText,\r\n  hostPatchProp,\r\n  hostInsert,\r\n  hostRemove\r\n}","import { ShapeFlags } from \"../utils/base.js\";\r\nimport  {\r\n  hostSetElementText,\r\n  hostPatchProp,\r\n  hostInsert,\r\n  hostRemove\r\n} from './dom.js';\r\n\r\nfunction isSameVNodeType (n1, n2) {\r\n  return n1.type === n2.type && n1.key === n2.key;\r\n};\r\n\r\nfunction patchKeyedChildren(c1, c2, container) {\r\n  let i = 0;\r\n  let e1 = c1.length - 1;\r\n  let e2 = c2.length - 1;\r\n\r\n  while (i <= e1 && i <= e2) {\r\n    const prevChild = c1[i];\r\n    const nextChild = c2[i];\r\n\r\n    if (!isSameVNodeType(prevChild, nextChild)) {\r\n      console.log(\"两个 child 不相等(从左往右比对)\");\r\n      break;\r\n    }\r\n\r\n    console.log(\"两个 child 相等，接下来对比着两个 child 节点(从左往右比对)\");\r\n    patch(prevChild, nextChild, container);\r\n    i++;\r\n  }\r\n\r\n  while (i <= e1 && i <= e2) {\r\n    // 从右向左取值\r\n    const prevChild = c1[e1];\r\n    const nextChild = c2[e2];\r\n\r\n    if (!isSameVNodeType(prevChild, nextChild)) {\r\n      console.log(\"两个 child 不相等(从右往左比对)\");\r\n      break;\r\n    }\r\n    console.log(\"两个 child 相等，接下来对比着两个 child 节点(从右往左比对)\");\r\n    patch(prevChild, nextChild, container);\r\n    e1--;\r\n    e2--;\r\n  }\r\n\r\n  if (i > e1 && i <= e2) {\r\n    // 如果是这种情况的话就说明 e2 也就是新节点的数量大于旧节点的数量\r\n    // 也就是说新增了 vnode\r\n    // 应该循环 c2\r\n    while (i <= e2) {\r\n      console.log(`需要新创建一个 vnode: ${c2[i].key}`);\r\n      patch(null, c2[i], container);\r\n      i++;\r\n    }\r\n  } else if (i > e2 && i <= e1) {\r\n    // 这种情况的话说明新节点的数量是小于旧节点的数量的\r\n    // 那么我们就需要把多余的\r\n    while (i <= e1) {\r\n      console.log(`需要删除当前的 vnode: ${c1[i].key}`);\r\n      hostRemove(c1[i].el);\r\n      i++;\r\n    }\r\n  } else {\r\n    // 左右两边都比对完了，然后剩下的就是中间部位顺序变动的\r\n    // 例如下面的情况\r\n    // a,b,[c,d,e],f,g\r\n    // a,b,[e,c,d],f,g\r\n\r\n    let s1 = i;\r\n    let s2 = i;\r\n    const keyToNewIndexMap = new Map();\r\n    // 先把 key 和 newIndex 绑定好，方便后续基于 key 找到 newIndex\r\n    for (let i = s2; i <= e2; i++) {\r\n      const nextChild = c2[i];\r\n      keyToNewIndexMap.set(nextChild.key, i);\r\n    }\r\n\r\n    // 需要处理新节点的数量\r\n    const toBePatched = e2 - s2 + 1;\r\n    const newIndexToOldIndexMap = new Array(toBePatched);\r\n    for (let index = 0; index < newIndexToOldIndexMap.length; index++) {\r\n      // 源码里面是用 0 来初始化的\r\n      // 但是有可能 0 是个正常值\r\n      // 我这里先用 -1 来初始化\r\n      newIndexToOldIndexMap[index] = -1;\r\n    }\r\n    // 遍历老节点\r\n    // 1. 需要找出老节点有，而新节点没有的 -> 需要把这个节点删除掉\r\n    // 2. 新老节点都有的，—> 需要 patch\r\n    for (i = s1; i <= e1; i++) {\r\n      const prevChild = c1[i];\r\n      const newIndex = keyToNewIndexMap.get(prevChild.key);\r\n      newIndexToOldIndexMap[newIndex] = i;\r\n\r\n      // 因为有可能 nexIndex 的值为0（0也是正常值）\r\n      // 所以需要通过值是不是 undefined 来判断\r\n      // 不能直接 if(newIndex) 来判断\r\n      if (newIndex === undefined) {\r\n        // 当前节点的key 不存在于 newChildren 中，需要把当前节点给删除掉\r\n        hostRemove(prevChild.el);\r\n      } else {\r\n        // 新老节点都存在\r\n        console.log(\"新老节点都存在\");\r\n        patch(prevChild, c2[newIndex], container);\r\n      }\r\n    }\r\n\r\n    // 遍历新节点\r\n    // 1. 需要找出老节点没有，而新节点有的 -> 需要把这个节点创建\r\n    // 2. 最后需要移动一下位置，比如 [c,d,e] -> [e,c,d]\r\n    for (i = e2; i >= s2; i--) {\r\n      const nextChild = c2[i];\r\n\r\n      if (newIndexToOldIndexMap[i] === -1) {\r\n        // 说明是个新增的节点\r\n        patch(null, c2[i], container);\r\n      } else {\r\n        // 有可能 i+1 没有元素 没有的话就直接设置为 null\r\n        // 在 hostInsert 函数内如果发现是 null 的话，会直接添加到父级容器内\r\n        const anchor = i + 1 >= e2 + 1 ? null : c2[i + 1];\r\n        hostInsert(nextChild.el, container, anchor && anchor.el);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction patchProps(el, oldProps, newProps) {\r\n  // key 存在 oldProps 里 也存在 newProps 内\r\n  // 以 newProps 作为基准\r\n  for (const key in newProps) {\r\n    const prevProp = oldProps[key];\r\n    const nextProp = newProps[key];\r\n    if (prevProp !== nextProp) {\r\n      // 对比属性\r\n      // 需要交给 host 来更新 key\r\n      hostPatchProp(el, key, prevProp, nextProp);\r\n    }\r\n  }\r\n\r\n  // oldProps 有，而 newProps 没有了\r\n  for (const key in oldProps) {\r\n    const prevProp = oldProps[key];\r\n    const nextProp = null;\r\n    if (!(key in newProps)) {\r\n      // 交给 host 更新的时候，把新的值设置为 null\r\n      hostPatchProp(el, key, prevProp, nextProp);\r\n    }\r\n  }\r\n}\r\n\r\nfunction patchChildren(oldVnode, vnode, container) {\r\n  const { shapeFlag: oldShapeFlag, children: oldChildren } = oldVnode;\r\n  const { shapeFlag, children } = vnode;\r\n\r\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n    if (children !== oldChildren) {\r\n      hostSetElementText(container, children);\r\n    }\r\n  } else {\r\n    // 对比两个 children\r\n    if (oldShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        patchKeyedChildren(oldChildren, children, container);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  patchProps,\r\n  patchChildren\r\n}","import { ShapeFlags } from \"../utils/base.js\";\r\nimport { queueJob } from \"./scheduler\";\r\nimport { createVNode } from './h';\r\nimport { effect } from \"./reactive\";\r\nimport  {\r\n  hostCreateElement,\r\n  hostSetElementText,\r\n  hostPatchProp,\r\n  hostInsert,\r\n} from './dom.js';\r\n\r\nimport {\r\n  patchProps,\r\n  patchChildren\r\n} from './diff.js'\r\n\r\nimport {\r\n  beforeMount,\r\n  mounted\r\n} from './lifecycle.js';\r\n\r\nconst render = (vnode, container) => {\r\n  patch(null, vnode, container);\r\n};\r\n\r\nfunction patch(oldVnode, vnode, container = null) {\r\n  const { type, shapeFlag } = vnode;\r\n  switch (type) {\r\n    // TODO: 各种类型\r\n    case \"text\":\r\n      break;\r\n    default:\r\n      if (shapeFlag & ShapeFlags.ELEMENT) {\r\n        processElement(oldVnode, vnode, container);\r\n      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\r\n        processComponent(oldVnode, vnode, container);\r\n      }\r\n  }\r\n}\r\n\r\nfunction processElement(n1, n2, container) {\r\n  if (!n1) {\r\n    mountElement(n2, container);\r\n  } else {\r\n    updateElement(n1, n2, container);\r\n  }\r\n}\r\n\r\nfunction updateElement(oldVnode, vnode, container) {\r\n  const oldProps = (oldVnode && oldVnode.props) || {};\r\n  const newProps = vnode.props || {};\r\n  // 需要把 el 挂载到新的 vnode\r\n  const el = (vnode.el = oldVnode.el);\r\n\r\n  // 对比\r\n  patchProps(el, oldProps, newProps);\r\n  patchChildren(oldVnode, vnode, el);\r\n}\r\n\r\nfunction mountElement(vnode, container) {\r\n  const { shapeFlag, props } = vnode;\r\n  // 1. 先创建 element\r\n  // 基于可扩展的渲染 api\r\n  const el = (vnode.el = hostCreateElement(vnode.type));\r\n\r\n  // 支持单子组件和多子组件的创建\r\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n    hostSetElementText(el, vnode.children);\r\n  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n    mountChildren(vnode.children, el);\r\n  }\r\n\r\n  // 处理 props\r\n  if (props) {\r\n    for (const key in props) {\r\n      const nextVal = props[key];\r\n      hostPatchProp(el, key, null, nextVal);\r\n    }\r\n  }\r\n  hostInsert(el, container);\r\n}\r\n\r\nfunction mountChildren(children, container) {\r\n  children.forEach((VNodeChild) => {\r\n    // todo\r\n    // 这里应该需要处理一下 vnodeChild\r\n    // 因为有可能不是 vnode 类型\r\n    console.log(\"mountChildren:\", VNodeChild);\r\n    patch(null, VNodeChild, container);\r\n  });\r\n}\r\n\r\nfunction processComponent(n1, n2, container) {\r\n  // 如果 n1 没有值的话，那么就是 mount\r\n  if (!n1) {\r\n    // 初始化 component\r\n    mountComponent(n2, container);\r\n  } else {\r\n    // todo\r\n    // updateComponent()\r\n  }\r\n}\r\n\r\nfunction mountComponent(initialVNode, container) {\r\n  const instance = (initialVNode.component = createComponentInstance(\r\n    initialVNode\r\n  ));\r\n\r\n  setupComponent(instance);\r\n  setupRenderEffect(instance, container);\r\n}\r\n\r\nfunction createComponentInstance(vnode) {\r\n  const instance = {\r\n    type: vnode.type,\r\n    vnode,\r\n    props: {},\r\n    proxy: null, // 其实就是数据\r\n    isMounted: false,\r\n  };\r\n\r\n  return instance;\r\n}\r\n\r\nfunction setupComponent(instance) {\r\n\r\n  initProps();\r\n  initSlots();\r\n\r\n  setupStatefulComponent(instance);\r\n}\r\n\r\nfunction initProps() {\r\n  // TODO:\r\n}\r\n\r\nfunction initSlots() {\r\n  // TODO:\r\n}\r\n\r\nfunction setupStatefulComponent(instance) {\r\n  const { setup, render } = instance.type;\r\n  const setupResult = setup && setup(instance.props);\r\n  instance.proxy = setupResult;\r\n  instance.render = render;\r\n}\r\n\r\n\r\nfunction setupRenderEffect(instance, container) {\r\n  /* \r\n    经过 sfc 后的代码应该是这样的\r\n\r\n    export function render(_ctx, _cache) {\r\n      return (_openBlock(), _createBlock(\"div\", {\r\n        class: \"abc\",\r\n        onClick: _ctx.addCount\r\n      }, _toDisplayString(_ctx.count.num), 9, [\"onClick\"]))\r\n    }\r\n  */\r\n  instance.update = effect(\r\n    function componentEffect() {\r\n      if (!instance.isMounted) {\r\n        const subTree = (instance.subTree = instance.render(instance.proxy));\r\n        beforeMount();\r\n        patch(null, subTree, container);\r\n        mounted();\r\n        instance.isMounted = true;\r\n      } else {\r\n        const nextTree = instance.render(instance.proxy);\r\n        const prevTree = instance.subTree;\r\n        instance.subTree = nextTree;\r\n\r\n        beforeMount();\r\n        patch(prevTree, nextTree, prevTree.el);\r\n        mounted();\r\n      }\r\n    },\r\n    {\r\n      scheduler: (effect) => {\r\n        // 把 effect 推到微任务的时候在执行\r\n        queueJob(effect)\r\n      },\r\n    }\r\n  );\r\n}\r\n\r\nconst createApp = (rootComponent, rootProps = null) => {\r\n\tconst app = {\r\n\t\tmount(rootDom) {\r\n\t\t\t// 此时 rootComponent = {setup, render}\r\n\t\t\tconst vnode = createVNode(rootComponent, rootProps);\r\n\t\t\tapp._container = rootDom;\r\n\t\t\trender(vnode, rootDom);\r\n\t\t},\r\n\t};\r\n\treturn app;\r\n};\r\n\r\nexport {\r\n  createApp,\r\n  render\r\n}"],"names":["Text","Symbol","ShapeFlags","ELEMENT","STATEFUL_COMPONENT","TEXT_CHILDREN","ARRAY_CHILDREN","getShapeFlag","type","blockStack","currentBlock","createVNode","props","children","patchFlag","dynamicProps","isBlockNode","vnode","el","component","key","shapeFlag","Array","isArray","queue","p","Promise","resolve","isFlushPending","nextTick","fn","then","queueJob","job","includes","push","flushJobs","queueFlush","shift","activeEffect","targetMap","WeakMap","effect","options","_effect","args","lazy","track","target","depsMap","get","set","Map","dep","Set","has","add","trigger","effects","forEach","e","scheduler","scheduleRun","hostSetElementText","text","innerText","hostPatchProp","preValue","nextValue","removeAttribute","setAttribute","addEventListener","hostInsert","child","parent","anchor","insertBefore","appendChild","hostRemove","parentNode","removeChild","isSameVNodeType","n1","n2","patchChildren","oldVnode","container","oldShapeFlag","oldChildren","c1","c2","i","e1","length","e2","prevChild","nextChild","patch","s1","s2","keyToNewIndexMap","newIndexToOldIndexMap","index","newIndex","undefined","patchKeyedChildren","render","oldProps","newProps","prevProp","nextProp","patchProps","updateElement","document","createElement","VNodeChild","mountChildren","nextVal","mountElement","processElement","initialVNode","instance","proxy","isMounted","setup","setupResult","setupStatefulComponent","setupComponent","update","nextTree","prevTree","subTree","setupRenderEffect","mountComponent","processComponent","value","_computed","dirty","runner","rootComponent","rootProps","app","mount","rootDom","_container","dynamicChildren","EMPTY_ARR","pop","flag","disableTracking","Proxy","prop","Reflect","newVal","obj","val","isObject","JSON","stringify","replacer","String"],"mappings":"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"}