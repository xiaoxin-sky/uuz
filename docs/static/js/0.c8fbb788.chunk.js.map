{"version":3,"sources":["controller/scroll.ts","views/Scroll.tsx","site/pages/scroll/index.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","controller/event.ts","controller/move.ts"],"names":["DistanceStatus","ScrollControl","direction","Refresh_Distance","distanceStatus","isRefreshable","beginTime","x","y","this","Date","now","getMoveDist","_getTimeTotal","EMPTY","tip","dist","DONE","HALF","MoveControl","Scroll","props","freshBoxClassName","refScrollArea","refScrollBody","eventControl","scrollControl","freshStore","Begin_Distance","End_Distance","oldDistance","scrollBottleneck","hideScrollTip","setState","transform","distance","time","updateScroll","freshHandler","scrollTip","setTimeout","getScrollBottleneck","offsetHeight","onStartHandler","event","state","canRefresh","banRefresh","start","markBeginTime","onMoveHandler","preventDefault","distanceY","move","markScrollTip","finalDistance","newDistance","onEndHandler","end","status","getUpdateStatus","resetRefreshStatus","scrollMat","loadHandler","className","expectMat","getExpectMat","finalPonit","EventControl","createEventList","listenerAllOfEle","removeAllOfEle","ref","ele","style","transition","children","React","PureComponent","TestContent","Array","num","fill","map","val","idx","key","TestReFresh","useState","setNum","console","log","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","protoProps","staticProps","prototype","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_typeof2","obj","Symbol","iterator","constructor","_typeof","_possibleConstructorReturn","self","call","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","create","value","eventList","willPreventDefault","willNotPreventDefault","$ele","isPassiveSupported","passiveSupported","passive","touchstart","mousedown","touchmove","mousemove","touchend","mouseup","keys","forEach","pd","indexOf","addEventListener","removeEventListener","zeroPoint","JSON","stringify","startPoint","endPoint","Prevent_Distance","lockDirection","isAnm","parse","Error","absX","Math","abs","absY","stopPropagation","point","getEventPoint","pageX","pageY","cancelable","assign","_getLockDirection","_getFinalEndPonit"],"mappings":"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","file":"static/js/0.c8fbb788.chunk.js","sourcesContent":["import MoveControl from './move';\n\ntype Point = {\n    x: number,\n    y: number\n}\n\nenum DistanceStatus { 'EMPTY', 'HALF', 'DONE' }\n\ntype Status = 'update' | 'reset' | 'none';\n\nclass ScrollControl extends MoveControl {\n    \n    Refresh_Distance: number;\n    distanceStatus?: DistanceStatus;\n    isRefreshable: boolean;\n    beginTime?: number;\n\n    constructor() {\n        super({direction: 'y'});\n        this.Refresh_Distance = 90;\n        this.isRefreshable = true;\n    }\n\n    _getFinalEndPonit(): Point {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n\n    markBeginTime() {\n        this.beginTime = Date.now();\n    }\n\n    _getTimeTotal(): number {\n        const endTime = Date.now();\n        const moveTime = endTime - this.beginTime!;\n        return moveTime;\n    }\n\n    getExpectMat(): number {\n        const distanceTotal = this.getMoveDist();\n        const moveTime = this._getTimeTotal();\n        // 速度 = 路程 / 时间\n        const speed = distanceTotal / moveTime;\n        // 计算期望缓冲距离\n        return speed * 234;\n    }\n\n    banRefresh() {\n        this.isRefreshable = false;\n    }\n\n    canRefresh() {\n        this.isRefreshable = true;\n    }\n\n    resetRefreshStatus() {\n        this.distanceStatus = DistanceStatus.EMPTY;\n    }\n\n    markScrollTip(): string {\n        let tip = '';\n        const dist = this.getMoveDist();\n        if (dist > this.Refresh_Distance) {\n            this.distanceStatus = DistanceStatus.DONE;\n            tip = '松开刷新';\n        } else if (dist > 0){\n            this.distanceStatus = DistanceStatus.HALF;\n            tip = '下拉刷新';\n        }\n        return tip;\n    }\n\n    getUpdateStatus(): Status {\n        if (this.distanceStatus === DistanceStatus.DONE) {\n            return 'update';\n        }\n        if (this.distanceStatus === DistanceStatus.HALF) {\n            return 'reset';\n        }\n        return 'none';\n    }\n\n}\n\nexport default ScrollControl;","import React from 'react';\nimport EventControl from '../controller/event';\nimport ScrollControl from '../controller/scroll';\n\ninterface ReScrollProps {\n  className?: String, // 刷新组件的 支持添加className\n  freshDistance?: number, // 触发刷新需要的：下拉距离\n  loadDistance?: number, // 触发加载需要的：距离最底部距离\n  freshHandler: Function | undefined, // 刷新执行的函数\n  loadHandler: Function | undefined // 加载执行的函数\n  children?: React.ReactNode\n}\n\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\nexport default  class Scroll extends React.PureComponent<ReScrollProps, any> {\n  freshBoxClassName: string;\n  refScrollArea?: HTMLDivElement | null;\n  refScrollBody?: HTMLDivElement | null;\n  eventControl?: EventControl;\n  scrollControl: ScrollControl;\n  freshStore: {[key: string]: Function};\n  Begin_Distance: number;\n  End_Distance: number;\n  oldDistance: number;\n  scrollBottleneck: number;\n\n  constructor(props: ReScrollProps) {\n    super(props);\n    this.freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\n    this.Begin_Distance = -50;\n    this.End_Distance = 26;\n    this.scrollControl = new ScrollControl();\n    this.freshStore = {\n      'update': this.updateScroll,\n      'reset': this.hideScrollTip,\n      'none': () => {}\n    }\n    this.oldDistance = 0;\n    this.scrollBottleneck = 0;\n    // state\n    this.state = {\n      transform: {\n        distance: this.Begin_Distance,\n        time: 0\n      },\n      scrollTip: ''\n    }\n  }\n\n  hideScrollTip = (): void => {\n    this.setState({\n      transform: {\n        distance: this.Begin_Distance,\n        time: 0.5\n      }\n    })\n  }\n\n  updateScroll = () => {\n    this.props.freshHandler!();\n    this.setState({\n      scrollTip: '刷新完成>>>',\n      transform: {\n        distance: 0,\n        time: 2\n      }\n    })\n    setTimeout(() => {\n      this.hideScrollTip()\n    }, 300);\n  }\n\n  // 可滚动距离\n  getScrollBottleneck = () => {\n    const body = this.refScrollBody!.offsetHeight;\n    const box = this.refScrollArea!.offsetHeight;\n    return  body - box + this.Begin_Distance;\n  }\n\n  //  滚动缓冲\n  scrollMat() {\n    const expectMat = this.scrollControl.getExpectMat();\n    let finalPonit = this.state.transform.distance + expectMat;\n    if (finalPonit > this.Begin_Distance) {\n      // 不能低于起点\n      finalPonit = this.Begin_Distance\n    } else if (finalPonit < -this.scrollBottleneck) {\n      // 不能超过终点\n      finalPonit = -this.scrollBottleneck;\n    }\n    \n    this.setState({\n      transform: {\n        distance: finalPonit,\n        time: 0.5\n      }\n    })\n  }\n\n  onStartHandler = (event: UseEvent): void => {\n    if (this.state.transform.distance === this.Begin_Distance) {\n      this.scrollControl.canRefresh()\n    } else {\n      this.scrollControl.banRefresh()\n    }\n    this.scrollControl.start(event);\n    this.oldDistance = this.state.transform.distance;\n    this.scrollBottleneck = this.getScrollBottleneck();\n    this.scrollControl.markBeginTime();\n  }\n\n  onMoveHandler = (event: UseEvent) => {\n    event.preventDefault();\n    const point = this.scrollControl.move(event);\n    const distanceY = point.y;\n    // 下拉动画\n    if (distanceY > 0 && this.scrollControl.isRefreshable) {\n      const scrollTip = this.scrollControl.markScrollTip();\n      this.setState({ scrollTip })\n    }\n    const newDistance = this.oldDistance + distanceY;\n    let finalDistance;\n    if (newDistance > this.Begin_Distance && !this.scrollControl.isRefreshable) {\n      // 顶点\n      finalDistance = this.Begin_Distance;\n    } else if (this.scrollBottleneck <= (-newDistance)) {\n      // 终点\n      finalDistance = -this.scrollBottleneck - this.End_Distance;\n    } else {\n      if (distanceY > 0) {\n        // 下拉刷新移动一半\n        finalDistance = this.oldDistance + distanceY/2;\n      } else {\n        finalDistance = newDistance;\n      }\n    }\n    this.setState({\n      transform: {\n        distance: finalDistance,\n        time: 0\n      }\n    })\n  }\n\n  onEndHandler = (): void => {\n    this.scrollControl.end();\n    // 需要刷新的时候执行 传入的刷新方法\n    if (typeof this.props.freshHandler === 'function') {\n      const status = this.scrollControl.getUpdateStatus();\n      if (status !== 'none') {\n        this.freshStore[status]();\n        this.scrollControl.resetRefreshStatus();\n        return;\n      };\n    }\n\n    // 滚动缓冲\n    this.scrollMat();\n\n    if (typeof this.props.loadHandler === 'function') {\n      if (this.scrollBottleneck <= (-this.state.transform.distance)) {\n        this.props.loadHandler();\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.eventControl = new EventControl(this.refScrollArea!);\n    this.eventControl.createEventList(this.onStartHandler, this.onMoveHandler, this.onEndHandler);\n    this.eventControl.listenerAllOfEle();\n  }\n\n  componentWillUnmount() {\n    this.eventControl!.removeAllOfEle();\n  }\n  \n  render() {\n    return <div\n      className={this.freshBoxClassName}\n      ref={ele => this.refScrollArea = ele}>\n        {/* 滚动区域 */}\n        <div\n          className=\"zui-scroll-area\"\n          ref={ele => this.refScrollBody = ele}\n          style={{\n            transform: `translate(0, ${this.state.transform.distance}px)`,\n            transition: `transform ${this.state.transform.time}s`\n          }}\n        >\n          {/* 刷新tip */}\n          <div className=\"zui-scroll-tip\">{this.state.scrollTip}</div>\n          {/* 真正的内容 */}\n          <div className=\"zui-scroll\">\n            {this.props.children}\n          </div>\n          <div className=\"zui-scroll-load-tip\">加载更多内容</div>\n        </div>\n      </div>\n  }\n}\n\n// import React, { useState, useEffect, useRef } from 'react';\n// import EventControl from '../controller/event';\n// import ScrollControl from '../controller/scroll';\n\n// interface ReScrollProps {\n//   className?: String, // 刷新组件的 支持添加className\n//   freshDistance?: number, // 触发刷新需要的：下拉距离\n//   loadDistance?: number, // 触发加载需要的：距离最底部距离\n//   freshHandler: Function | undefined, // 刷新执行的函数\n//   loadHandler: Function | undefined // 加载执行的函数\n//   children?: React.ReactNode\n// }\n\n// type UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\n// export default function Scroll(props: ReScrollProps) {\n\n//   const Begin_Distance = -50;\n\n//   const [scrollTip, setScrollTip] = useState('');\n//   const [transform, setTransform] = useState({distance: Begin_Distance, time: 0});\n//   const [scrollBottleneck, setScrollBottleneck] = useState(0);\n//   const [scrollControl] = useState(new ScrollControl());\n//   const [bindFlag, setBindFlag] = useState(0);\n\n//   let refScrollArea: HTMLDivElement | null;\n//   let refScrollBody = useRef(null);\n\n//   let freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\n  \n//   const hideScrollTip = (): void => {\n//     setTransform({\n//       distance: Begin_Distance,\n//       time: 0.5\n//     })\n//   }\n  \n//   const updateScroll = () => {\n//     props.freshHandler!();\n//     setTransform({\n//       distance: 0,\n//       time: 2\n//     })\n//     setScrollTip('刷新中 >>>');\n//     setTimeout(() => {\n//       hideScrollTip()\n//       setBindFlag(bindFlag + 1);\n//     }, 300);\n//   }\n\n//   const freshStore = {\n//     'update': updateScroll,\n//     'reset': hideScrollTip,\n//     'none': () => {}\n//   }\n\n//   const onStartHandler = (event: UseEvent): void => {\n//     if (transform.distance === Begin_Distance) {\n//       scrollControl.canRefresh()\n//     } else {\n//       scrollControl.banRefresh()\n//     }\n//     scrollControl.start(event);\n//     console.log('开始')\n//   }\n\n//   const onMoveHandler = (event: UseEvent) => {\n//     event.preventDefault();\n//     const point = scrollControl.move(event);\n//     const distanceY = point.y;\n//     // 下拉动画\n//     if (distanceY > 0 && scrollControl.isRefreshable) {\n//       const tip = scrollControl.markScrollTip();\n//       setScrollTip(tip);\n//     }\n\n//     const newDistance = transform.distance + distanceY;\n//     if (newDistance > Begin_Distance && !scrollControl.isRefreshable) {\n//       setTransform({\n//         distance: Begin_Distance,\n//         time: 0\n//       })\n//     } else {\n//       setTransform({\n//         distance: transform.distance + distanceY,\n//         time: 0\n//       })\n//     }\n//   }\n\n//   const onEndHandler = (): void => {\n//     // 需要刷新的时候执行 传入的刷新方法\n//     if (typeof props.freshHandler === 'function') {\n//       const status = scrollControl.getUpdateStatus();\n//       if (status !== 'none') {\n//         freshStore[status]();\n//         scrollControl.end();\n//         return;\n//       };\n//     }\n\n//     if (typeof props.loadHandler === 'function') {\n//       const scrollEle = (refScrollBody.current as any);\n//       console.log(scrollEle.offsetHeight, scrollBottleneck, (-transform.distance))\n//       if (scrollEle.offsetHeight <= scrollBottleneck + (-transform.distance)) {\n//         props.loadHandler();\n//         setBindFlag(bindFlag + 1);\n//       }\n//     }\n//   }\n\n//   useEffect(() => {\n//     setScrollBottleneck(refScrollArea!.offsetHeight);\n//     setBindFlag(bindFlag + 1);\n//   }, [])\n\n//   useEffect(() => {\n//     const eventControl = new EventControl(refScrollArea!);\n//     eventControl.createEventList(onStartHandler, onMoveHandler, onEndHandler);\n//     eventControl.listenerAllOfEle();\n//     return () => {\n//         eventControl.removeAllOfEle();\n//     }\n//   }, [bindFlag])\n\n//   return <div\n//     className={freshBoxClassName}\n//     ref={ele => refScrollArea = ele}>\n//       {/* 滚动区域 */}\n//       <div\n//         className=\"zui-scroll-area\"\n//         ref={refScrollBody}\n//         style={{\n//           transform: `translate(0, ${transform.distance}px)`,\n//           transition: `transform ${transform.time}s`\n//         }}\n//       >\n//         {/* 刷新tip */}\n//         <div className=\"zui-scroll-tip\">{scrollTip}</div>\n//         {/* 真正的内容 */}\n//         <div className=\"zui-scroll\">\n//           {props.children}\n//         </div>\n//       </div>\n//     </div>\n// }","import React, { useState } from 'react';\n\nimport Scroll from '../../../views/Scroll'\n\nfunction TestContent(props) {\n    return Array(props.num).fill(0).map((val, idx) => {\n        return <div className=\"test-content\" key={idx}>{idx + 1}：需用手机模式测试</div>\n    })\n}\n\nfunction TestReFresh() {\n\n    const [num, setNum] = useState(50);\n\n    const freshHandler = () => {\n        console.log('刷新')\n        setNum(50)\n    }\n\n    const loadHandler = () => {\n        console.log('加载')\n        setNum(num + 30);\n    }\n\n    return <Scroll\n        className=\"test-fresh\"\n        freshHandler={freshHandler}\n        loadHandler={loadHandler}>\n        <TestContent num={num}></TestContent>\n    </Scroll>\n}\n\nexport default TestReFresh;","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import { passiveSupported } from \"../utils/base\";\n\nclass EventControl {\n    \n    eventList: {[key: string]: Function};\n    willPreventDefault: object | boolean;\n    willNotPreventDefault: object | boolean;\n    $ele: HTMLDivElement;\n\n    constructor(ele: HTMLDivElement) {\n        this.eventList = {};\n        const isPassiveSupported = passiveSupported();\n        this.willPreventDefault = isPassiveSupported ? { passive: false } : false;\n        this.willNotPreventDefault = isPassiveSupported ? { passive: true } : false;\n        this.$ele = ele;\n    }\n\n    createEventList(start: Function, move: Function, end: Function) {\n        this.eventList =  {\n            touchstart: start,\n            mousedown: start,\n            touchmove: move,\n            mousemove: move,\n            touchend: end,\n            mouseup: end,\n        }\n    }\n\n    listenerAllOfEle() {\n        Object.keys(this.eventList).forEach(key => {\n            const pd = key.indexOf('move') >= 0 ? this.willPreventDefault : this.willNotPreventDefault;\n            this.$ele.addEventListener(key, this.eventList[key] as any, pd as any);\n        })\n    }\n\n    removeAllOfEle() {\n        Object.keys(this.eventList).forEach(key => {\n            this.$ele.removeEventListener(key, this.eventList[key] as any);\n        })\n    }\n}\n\nexport default EventControl;\n","import { getEventPoint } from \"../utils/base\";\nimport { passiveSupported } from \"../utils/base\";\n\ntype Point = {\n    x: number,\n    y: number\n}\n\ntype Direction = 'x' | 'y';\n\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\ninterface MoveControlProps {\n    direction?: Direction\n}\n\nconst zeroPoint = JSON.stringify({ x: 0, y: 0 });\n\nclass MoveControl {\n\n    startPoint: Point;\n    distance: Point;\n    endPoint: Point;\n    direction: Direction;\n    Prevent_Distance: number;\n    lockDirection: Direction | null;\n    isAnm: boolean;\n\n    constructor({direction = 'x'}: MoveControlProps) {\n        this.direction = direction;\n        this.startPoint = JSON.parse(zeroPoint);\n        this.distance = JSON.parse(zeroPoint);\n        this.endPoint = JSON.parse(zeroPoint);\n        this.Prevent_Distance = 5;\n        this.lockDirection = null;\n        this.isAnm = false;\n    }\n\n    // 终止时位置调整\n    _getFinalEndPonit(): Point {\n        throw Error('_getFinalEndPonit 需要被重写');\n    }\n\n    // 方向锁定\n    _getLockDirection(): Direction | null {\n        const absX = Math.abs(this.distance.x);\n        const absY = Math.abs(this.distance.y);\n\n        let lockDirection: Direction | null = null;\n\n        if (this.direction === 'x') {\n            if (absX >= absY && absX > this.Prevent_Distance) {\n                lockDirection = 'x';\n            } else if (absY > this.Prevent_Distance) {\n                lockDirection = 'y';\n            }\n        } else {\n            if (absY >= absX && absY > this.Prevent_Distance) {\n                lockDirection = 'y';\n            } else if (absX > this.Prevent_Distance) {\n                lockDirection = 'x';\n            }\n        }\n        \n        return lockDirection;\n    }\n\n    // 移动过程中的移动距离 = 最后停留点 - 触摸点移动距离\n    getMoveDist() {\n        const dist = this.endPoint[this.direction] - this.distance[this.direction];\n        return dist;\n    }\n\n    // preventDefault(event: UseEvent) {\n    //     if (event.cancelable) { // 是否可以取消默认事件\n    //         event.preventDefault();\n    //     }\n    // }\n\n    // freezeBody() {\n    //     const isPassiveSupported = passiveSupported();\n    //     const willPreventDefault = isPassiveSupported ? { passive: false } : false;\n    //     document.body.addEventListener('touchmove', (this.preventDefault as any), willPreventDefault);\n    // }\n\n    // unfreezeBody() {\n    //     document.body.removeEventListener('touchmove', (this.preventDefault as any));\n    // }\n\n    start(event: UseEvent): void {\n        event.stopPropagation();\n        this.isAnm = true;\n        const point = getEventPoint(event);\n        this.lockDirection = null;\n        this.startPoint = {\n            x: point.pageX,\n            y: point.pageY\n        }\n    }\n\n    // 移动时：获取移动距离\n    move(event: UseEvent): Point {\n        if (this.isAnm) {\n            event.stopPropagation();\n            const point = getEventPoint(event);\n            this.distance = {\n                x: this.startPoint.x - point.pageX,\n                y: this.startPoint.y - point.pageY,\n            }\n            if (!this.lockDirection) {\n                // if (event.cancelable) {\n                //     event.preventDefault();\n                // }\n                this.lockDirection = this._getLockDirection();\n            } else if (this.direction === this.lockDirection) {\n                if (event.cancelable) { // 是否可以取消默认事件\n                    event.preventDefault();\n                }\n                return Object.assign({x: 0, y: 0}, {[this.direction]: this.getMoveDist()})\n            }\n        }\n        // 如果return movePoint 那么位置不变\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n\n    end(): Point {\n        this.isAnm = false;\n        return this._getFinalEndPonit();\n    }\n\n}\n\nexport default MoveControl;\n"],"sourceRoot":""}