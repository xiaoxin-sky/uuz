{"version":3,"sources":["controller/scroll.ts","views/Scroll.tsx","site/pages/scroll/index.js","../node_modules/_@babel_runtime@7.8.7@@babel/runtime/helpers/esm/createClass.js","controller/event.ts","controller/move.ts"],"names":["DistanceStatus","ScrollControl","direction","Refresh_Distance","distanceStatus","isRefreshable","beginTime","x","y","this","_markBeginTime","distance","Date","now","getMoveDist","_getTimeTotal","EMPTY","tip","dist","DONE","HALF","MoveControl","Scroll","props","freshBoxClassName","refScrollWarp","refScrollBody","eventControl","scrollControl","freshStore","Begin_Distance","End_Distance","oldDistance","scrollBottleneck","hideScrollTip","setState","transform","time","updateScroll","freshHandler","scrollTip","setTimeout","getScrollBottleneck","offsetHeight","scrollMat","expectMat","getExpectMat","finalPonit","state","onStartHandler","event","start","isRefreshAble","setRefreshAble","onMoveHandler","preventDefault","distanceY","move","markScrollTip","finalDistance","newDistance","onEndHandler","end","status","getUpdateStatus","resetRefreshStatus","loadHandler","className","EventControl","createEventList","listenerAllOfEle","removeAllOfEle","ref","ele","style","transition","children","React","PureComponent","TestContent","Array","num","fill","map","val","idx","key","TestReFresh","useState","setNum","console","log","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","Constructor","protoProps","staticProps","prototype","eventList","willPreventDefault","willNotPreventDefault","$ele","isPassiveSupported","passiveSupported","passive","window","touchstart","touchmove","touchend","mousedown","mousemove","mouseup","keys","forEach","pd","indexOf","addEventListener","removeEventListener","zeroPoint","JSON","stringify","startPoint","endPoint","Prevent_Distance","lockDirection","isAnm","parse","Error","absX","Math","abs","absY","point","getEventPoint","pageX","pageY","_resetSomething","assign","_getLockDirection","_getFinalEndPonit"],"mappings":"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","file":"static/js/1.10116ce3.chunk.js","sourcesContent":["import MoveControl from './move';\r\n\r\ntype Point = {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\nenum DistanceStatus { 'EMPTY', 'HALF', 'DONE' }\r\n\r\ntype Status = 'update' | 'reset' | 'none';\r\n\r\nclass ScrollControl extends MoveControl {\r\n    \r\n    Refresh_Distance: number;\r\n    distanceStatus?: DistanceStatus;\r\n    isRefreshable: boolean;\r\n    beginTime?: number;\r\n\r\n    constructor() {\r\n        super({direction: 'y'});\r\n        this.Refresh_Distance = 90;\r\n        this.isRefreshable = true;\r\n    }\r\n\r\n    _getFinalEndPonit(): Point {\r\n        return {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n    }\r\n\r\n    _resetSomething() {\r\n        this._markBeginTime();\r\n        this.distance[this.direction] = 0;\r\n    }\r\n\r\n    _markBeginTime() {\r\n        this.beginTime = Date.now();\r\n    }\r\n\r\n    _getTimeTotal(): number {\r\n        const endTime = Date.now();\r\n        const moveTime = endTime - this.beginTime!;\r\n        return moveTime;\r\n    }\r\n\r\n    getExpectMat(): number {\r\n        const distanceTotal = this.getMoveDist();\r\n        const moveTime = this._getTimeTotal();\r\n        // 速度 = 路程 / 时间\r\n        const speed = distanceTotal / moveTime;\r\n        // 计算期望缓冲距离\r\n        const mat = speed * 234;\r\n        return mat;\r\n    }\r\n\r\n    setRefreshAble(isRefreshable: boolean) {\r\n        this.isRefreshable = isRefreshable;\r\n    }\r\n\r\n    resetRefreshStatus() {\r\n        this.distanceStatus = DistanceStatus.EMPTY;\r\n    }\r\n\r\n    markScrollTip(): string {\r\n        let tip = '';\r\n        const dist = this.getMoveDist();\r\n        if (dist > this.Refresh_Distance) {\r\n            this.distanceStatus = DistanceStatus.DONE;\r\n            tip = '松开刷新';\r\n        } else if (dist > 0){\r\n            this.distanceStatus = DistanceStatus.HALF;\r\n            tip = '下拉刷新';\r\n        }\r\n        return tip;\r\n    }\r\n\r\n    getUpdateStatus(): Status {\r\n        if (this.distanceStatus === DistanceStatus.DONE) {\r\n            return 'update';\r\n        }\r\n        if (this.distanceStatus === DistanceStatus.HALF) {\r\n            return 'reset';\r\n        }\r\n        return 'none';\r\n    }\r\n\r\n}\r\n\r\nexport default ScrollControl;","import React from 'react';\r\nimport EventControl from '../controller/event';\r\nimport ScrollControl from '../controller/scroll';\r\n\r\ninterface ReScrollProps {\r\n  className?: String, // 刷新组件的 支持添加className\r\n  freshDistance?: number, // 触发刷新需要的：下拉距离\r\n  loadDistance?: number, // 触发加载需要的：距离最底部距离\r\n  freshHandler: Function | undefined, // 刷新执行的函数\r\n  loadHandler: Function | undefined // 加载执行的函数\r\n  children?: React.ReactNode\r\n}\r\n\r\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\r\n\r\nexport default  class Scroll extends React.PureComponent<ReScrollProps, any> {\r\n  freshBoxClassName: string;\r\n  refScrollWarp?: HTMLDivElement | null;\r\n  refScrollBody?: HTMLDivElement | null;\r\n  eventControl?: EventControl;\r\n  scrollControl: ScrollControl;\r\n  freshStore: {[key: string]: Function};\r\n  Begin_Distance: number;\r\n  End_Distance: number;\r\n  oldDistance: number;\r\n  scrollBottleneck: number;\r\n  // scrolling: boolean;\r\n\r\n  constructor(props: ReScrollProps) {\r\n    super(props);\r\n    this.freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\r\n    this.Begin_Distance = -50;\r\n    this.End_Distance = 26;\r\n    this.scrollControl = new ScrollControl(); // 滚动控制器只返回距离和状态，不操作dom\r\n    this.freshStore = {\r\n      'update': this.updateScroll,\r\n      'reset': this.hideScrollTip,\r\n      'none': () => {}\r\n    }\r\n    this.oldDistance = 0;\r\n    this.scrollBottleneck = 0;\r\n    // this.scrolling = false\r\n    // state\r\n    this.state = {\r\n      transform: {\r\n        distance: this.Begin_Distance,\r\n        time: 0\r\n      },\r\n      scrollTip: ''\r\n    }\r\n  }\r\n\r\n  hideScrollTip = (): void => {\r\n    this.setState({\r\n      transform: {\r\n        distance: this.Begin_Distance,\r\n        time: 0.5\r\n      }\r\n    })\r\n  }\r\n\r\n  updateScroll = () => {\r\n    this.props.freshHandler!();\r\n    // this.scrolling = true;\r\n    this.setState({\r\n      scrollTip: '刷新完成>>>',\r\n      transform: {\r\n        distance: 0,\r\n        time: 2\r\n      }\r\n    })\r\n    setTimeout(() => {\r\n      this.hideScrollTip()\r\n    }, 300);\r\n  }\r\n\r\n  // 可滚动距离\r\n  getScrollBottleneck = () => {\r\n    const body = this.refScrollBody!.offsetHeight;\r\n    const box = this.refScrollWarp!.offsetHeight;\r\n    return  body - box + this.Begin_Distance;\r\n  }\r\n\r\n  //  滚动缓冲\r\n  scrollMat = () => {\r\n    const expectMat = this.scrollControl.getExpectMat();\r\n    if (expectMat) {\r\n      // this.scrolling = true;\r\n      let finalPonit = this.state.transform.distance + expectMat;\r\n      if (finalPonit > this.Begin_Distance) {\r\n        // 不能低于起点\r\n        finalPonit = this.Begin_Distance\r\n      } else if (finalPonit < -this.scrollBottleneck) {\r\n        // 不能超过终点\r\n        finalPonit = -this.scrollBottleneck;\r\n      }\r\n      this.setState({\r\n        transform: {\r\n          distance: finalPonit,\r\n          time: 0.5\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  onStartHandler = (event: UseEvent): void => {\r\n    this.setState({\r\n      transform: {\r\n        distance: this.state.transform.distance,\r\n        time: 0\r\n      }\r\n    })\r\n    this.scrollControl.start(event);\r\n    const isRefreshAble = this.state.transform.distance === this.Begin_Distance;\r\n    this.scrollControl.setRefreshAble(isRefreshAble);\r\n    \r\n    this.oldDistance = this.state.transform.distance;\r\n    this.scrollBottleneck = this.getScrollBottleneck();\r\n  }\r\n\r\n  onMoveHandler = (event: UseEvent) => {\r\n    event.preventDefault();\r\n    const point = this.scrollControl.move(event);\r\n    const distanceY = point.y;\r\n    // 下拉动画\r\n    if (distanceY > 0 && this.scrollControl.isRefreshable) {\r\n      const scrollTip = this.scrollControl.markScrollTip();\r\n      this.setState({ scrollTip })\r\n    }\r\n    const newDistance = this.oldDistance + distanceY;\r\n    let finalDistance;\r\n    if (!this.scrollControl.isRefreshable &&\r\n        newDistance > this.Begin_Distance) { // 顶点\r\n      finalDistance = this.Begin_Distance;\r\n    } else if (this.scrollBottleneck <= (-newDistance)) { // 终点\r\n      finalDistance = -this.scrollBottleneck - this.End_Distance;\r\n    } else {\r\n      if (distanceY > 0) { // 下拉刷新移动一半\r\n        finalDistance = this.oldDistance + distanceY/2;\r\n      } else {\r\n        finalDistance = newDistance;\r\n      }\r\n    }\r\n    this.setState({\r\n      transform: {\r\n        distance: finalDistance,\r\n        time: 0\r\n      }\r\n    })\r\n  }\r\n\r\n  onEndHandler = (): void => {\r\n    this.scrollControl.end();\r\n    // 需要刷新的时候执行 传入的刷新方法\r\n    if (typeof this.props.freshHandler === 'function') {\r\n      const status = this.scrollControl.getUpdateStatus();\r\n      if (status !== 'none') {\r\n        this.freshStore[status]();\r\n        this.scrollControl.resetRefreshStatus();\r\n        return;\r\n      };\r\n    }\r\n\r\n    // 滚动缓冲\r\n    this.scrollMat();\r\n\r\n    if (typeof this.props.loadHandler === 'function') {\r\n      if (this.scrollBottleneck <= (-this.state.transform.distance)) {\r\n        this.props.loadHandler();\r\n      }\r\n    }\r\n  }\r\n\r\n  // transitionEndHandler = () => {\r\n  //   this.scrolling = false;\r\n  // }\r\n\r\n  componentDidMount() {\r\n    this.eventControl = new EventControl(this.refScrollWarp!);\r\n    this.eventControl.createEventList(this.onStartHandler, this.onMoveHandler, this.onEndHandler);\r\n    this.eventControl.listenerAllOfEle();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.eventControl!.removeAllOfEle();\r\n  }\r\n  \r\n  render() {\r\n    return <div\r\n      className={this.freshBoxClassName}\r\n      // onTransitionEnd={this.transitionEndHandler}\r\n      ref={ele => this.refScrollWarp = ele}>\r\n        {/* 滚动区域 */}\r\n        <div\r\n          className=\"zui-scroll-area\"\r\n          ref={ele => this.refScrollBody = ele}\r\n          style={{\r\n            transform: `translate(0, ${this.state.transform.distance}px)`,\r\n            transition: `transform ${this.state.transform.time}s`\r\n          }}\r\n        >\r\n          {/* 刷新tip */}\r\n          <div className=\"zui-scroll-tip\">{this.state.scrollTip}</div>\r\n          {/* 真正的内容 */}\r\n          <div className=\"zui-scroll\">\r\n            {this.props.children}\r\n          </div>\r\n          <div className=\"zui-scroll-load-tip\">加载更多内容</div>\r\n        </div>\r\n      </div>\r\n  }\r\n}\r\n\r\n// import React, { useState, useEffect, useRef } from 'react';\r\n// import EventControl from '../controller/event';\r\n// import ScrollControl from '../controller/scroll';\r\n\r\n// interface ReScrollProps {\r\n//   className?: String, // 刷新组件的 支持添加className\r\n//   freshDistance?: number, // 触发刷新需要的：下拉距离\r\n//   loadDistance?: number, // 触发加载需要的：距离最底部距离\r\n//   freshHandler: Function | undefined, // 刷新执行的函数\r\n//   loadHandler: Function | undefined // 加载执行的函数\r\n//   children?: React.ReactNode\r\n// }\r\n\r\n// type UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\r\n\r\n// export default function Scroll(props: ReScrollProps) {\r\n\r\n//   const Begin_Distance = -50;\r\n\r\n//   const [scrollTip, setScrollTip] = useState('');\r\n//   const [transform, setTransform] = useState({distance: Begin_Distance, time: 0});\r\n//   const [scrollBottleneck, setScrollBottleneck] = useState(0);\r\n//   const [scrollControl] = useState(new ScrollControl());\r\n//   const [bindFlag, setBindFlag] = useState(0);\r\n\r\n//   let refScrollWarp: HTMLDivElement | null;\r\n//   let refScrollBody = useRef(null);\r\n\r\n//   let freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\r\n  \r\n//   const hideScrollTip = (): void => {\r\n//     setTransform({\r\n//       distance: Begin_Distance,\r\n//       time: 0.5\r\n//     })\r\n//   }\r\n  \r\n//   const updateScroll = () => {\r\n//     props.freshHandler!();\r\n//     setTransform({\r\n//       distance: 0,\r\n//       time: 2\r\n//     })\r\n//     setScrollTip('刷新中 >>>');\r\n//     setTimeout(() => {\r\n//       hideScrollTip()\r\n//       setBindFlag(bindFlag + 1);\r\n//     }, 300);\r\n//   }\r\n\r\n//   const freshStore = {\r\n//     'update': updateScroll,\r\n//     'reset': hideScrollTip,\r\n//     'none': () => {}\r\n//   }\r\n\r\n//   const onStartHandler = (event: UseEvent): void => {\r\n//     if (transform.distance === Begin_Distance) {\r\n//       scrollControl.canRefresh()\r\n//     } else {\r\n//       scrollControl.banRefresh()\r\n//     }\r\n//     scrollControl.start(event);\r\n//     console.log('开始')\r\n//   }\r\n\r\n//   const onMoveHandler = (event: UseEvent) => {\r\n//     event.preventDefault();\r\n//     const point = scrollControl.move(event);\r\n//     const distanceY = point.y;\r\n//     // 下拉动画\r\n//     if (distanceY > 0 && scrollControl.isRefreshable) {\r\n//       const tip = scrollControl.markScrollTip();\r\n//       setScrollTip(tip);\r\n//     }\r\n\r\n//     const newDistance = transform.distance + distanceY;\r\n//     if (newDistance > Begin_Distance && !scrollControl.isRefreshable) {\r\n//       setTransform({\r\n//         distance: Begin_Distance,\r\n//         time: 0\r\n//       })\r\n//     } else {\r\n//       setTransform({\r\n//         distance: transform.distance + distanceY,\r\n//         time: 0\r\n//       })\r\n//     }\r\n//   }\r\n\r\n//   const onEndHandler = (): void => {\r\n//     // 需要刷新的时候执行 传入的刷新方法\r\n//     if (typeof props.freshHandler === 'function') {\r\n//       const status = scrollControl.getUpdateStatus();\r\n//       if (status !== 'none') {\r\n//         freshStore[status]();\r\n//         scrollControl.end();\r\n//         return;\r\n//       };\r\n//     }\r\n\r\n//     if (typeof props.loadHandler === 'function') {\r\n//       const scrollEle = (refScrollBody.current as any);\r\n//       console.log(scrollEle.offsetHeight, scrollBottleneck, (-transform.distance))\r\n//       if (scrollEle.offsetHeight <= scrollBottleneck + (-transform.distance)) {\r\n//         props.loadHandler();\r\n//         setBindFlag(bindFlag + 1);\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   useEffect(() => {\r\n//     setScrollBottleneck(refScrollWarp!.offsetHeight);\r\n//     setBindFlag(bindFlag + 1);\r\n//   }, [])\r\n\r\n//   useEffect(() => {\r\n//     const eventControl = new EventControl(refScrollWarp!);\r\n//     eventControl.createEventList(onStartHandler, onMoveHandler, onEndHandler);\r\n//     eventControl.listenerAllOfEle();\r\n//     return () => {\r\n//         eventControl.removeAllOfEle();\r\n//     }\r\n//   }, [bindFlag])\r\n\r\n//   return <div\r\n//     className={freshBoxClassName}\r\n//     ref={ele => refScrollWarp = ele}>\r\n//       {/* 滚动区域 */}\r\n//       <div\r\n//         className=\"zui-scroll-area\"\r\n//         ref={refScrollBody}\r\n//         style={{\r\n//           transform: `translate(0, ${transform.distance}px)`,\r\n//           transition: `transform ${transform.time}s`\r\n//         }}\r\n//       >\r\n//         {/* 刷新tip */}\r\n//         <div className=\"zui-scroll-tip\">{scrollTip}</div>\r\n//         {/* 真正的内容 */}\r\n//         <div className=\"zui-scroll\">\r\n//           {props.children}\r\n//         </div>\r\n//       </div>\r\n//     </div>\r\n// }","import React, { useState } from 'react';\r\n\r\nimport Scroll from '../../../views/Scroll'\r\n\r\nfunction TestContent(props) {\r\n    return Array(props.num).fill(0).map((val, idx) => {\r\n        return <div className=\"test-content\" key={idx}>{idx + 1}：需用手机模式测试</div>\r\n    })\r\n}\r\n\r\nfunction TestReFresh() {\r\n\r\n    const [num, setNum] = useState(50);\r\n\r\n    const freshHandler = () => {\r\n        console.log('刷新')\r\n        setNum(50)\r\n    }\r\n\r\n    const loadHandler = () => {\r\n        console.log('加载')\r\n        setNum(num + 30);\r\n    }\r\n\r\n    return <Scroll\r\n        className=\"test-fresh\"\r\n        freshHandler={freshHandler}\r\n        loadHandler={loadHandler}>\r\n        <TestContent num={num}></TestContent>\r\n    </Scroll>\r\n}\r\n\r\nexport default TestReFresh;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import { passiveSupported } from \"../utils/base\";\r\n\r\nclass EventControl {\r\n    \r\n    eventList: {[key: string]: Function};\r\n    willPreventDefault: object | boolean;\r\n    willNotPreventDefault: object | boolean;\r\n    $ele: HTMLDivElement;\r\n\r\n    constructor(ele: HTMLDivElement) {\r\n        this.eventList = {};\r\n        const isPassiveSupported = passiveSupported();\r\n        this.willPreventDefault = isPassiveSupported ? { passive: false } : false;\r\n        this.willNotPreventDefault = isPassiveSupported ? { passive: true } : false;\r\n        this.$ele = ele;\r\n    }\r\n\r\n    createEventList(start: Function, move: Function, end: Function) {\r\n        if ('ontouchstart' in window) {\r\n            this.eventList =  {\r\n                touchstart: start,\r\n                touchmove: move,\r\n                touchend: end,\r\n            }\r\n        } else {\r\n            this.eventList =  {\r\n                mousedown: start,\r\n                mousemove: move,\r\n                mouseup: end,\r\n            }\r\n        }\r\n    }\r\n\r\n    listenerAllOfEle() {\r\n        Object.keys(this.eventList).forEach(key => {\r\n            const pd = key.indexOf('move') >= 0 ? this.willPreventDefault : this.willNotPreventDefault;\r\n            this.$ele.addEventListener(key, this.eventList[key] as any, pd as any);\r\n        })\r\n    }\r\n\r\n    removeAllOfEle() {\r\n        Object.keys(this.eventList).forEach(key => {\r\n            this.$ele.removeEventListener(key, this.eventList[key] as any);\r\n        })\r\n    }\r\n}\r\n\r\nexport default EventControl;\r\n","import { getEventPoint } from \"../utils/base\";\r\n\r\ntype Point = {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\ntype Direction = 'x' | 'y';\r\n\r\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\r\n\r\ninterface MoveControlProps {\r\n    direction?: Direction\r\n}\r\n\r\nconst zeroPoint = JSON.stringify({ x: 0, y: 0 });\r\n\r\nclass MoveControl {\r\n\r\n    startPoint: Point;\r\n    distance: Point;\r\n    endPoint: Point;\r\n    direction: Direction;\r\n    Prevent_Distance: number;\r\n    lockDirection: Direction | null;\r\n    isAnm: boolean;\r\n\r\n    constructor({direction = 'x'}: MoveControlProps) {\r\n        this.direction = direction;\r\n        this.startPoint = JSON.parse(zeroPoint);\r\n        this.distance = JSON.parse(zeroPoint);\r\n        this.endPoint = JSON.parse(zeroPoint);\r\n        this.Prevent_Distance = 5;\r\n        this.lockDirection = null;\r\n        this.isAnm = false;\r\n    }\r\n\r\n    // 终止时位置调整\r\n    _getFinalEndPonit(): Point {\r\n        throw Error('_getFinalEndPonit 需要被重写');\r\n    }\r\n\r\n    // 起点重置项\r\n    _resetSomething() {\r\n        // 需要时重写\r\n        this.distance[this.direction] = 0;\r\n    }\r\n\r\n    // 方向锁定\r\n    _getLockDirection(): Direction | null {\r\n        const absX = Math.abs(this.distance.x);\r\n        const absY = Math.abs(this.distance.y);\r\n\r\n        let lockDirection: Direction | null = null;\r\n\r\n        if (this.direction === 'x') {\r\n            if (absX >= absY && absX > this.Prevent_Distance) {\r\n                lockDirection = 'x';\r\n            } else if (absY > this.Prevent_Distance) {\r\n                lockDirection = 'y';\r\n            }\r\n        } else {\r\n            if (absY >= absX && absY > this.Prevent_Distance) {\r\n                lockDirection = 'y';\r\n            } else if (absX > this.Prevent_Distance) {\r\n                lockDirection = 'x';\r\n            }\r\n        }\r\n        \r\n        return lockDirection;\r\n    }\r\n\r\n    // 移动过程中的移动距离 = 最后停留点 - 触摸点移动距离\r\n    getMoveDist() {\r\n        const dist = this.endPoint[this.direction] - this.distance[this.direction];\r\n        return dist;\r\n    }\r\n\r\n    start(event: UseEvent): void {\r\n        this.isAnm = true;\r\n        const point = getEventPoint(event);\r\n        this.lockDirection = null;\r\n        this.startPoint = {\r\n            x: point.pageX,\r\n            y: point.pageY\r\n        }\r\n        this._resetSomething();\r\n    }\r\n\r\n    // 移动时：获取移动距离\r\n    move(event: UseEvent): Point {\r\n        if (this.isAnm) {\r\n            const point = getEventPoint(event);\r\n            this.distance = {\r\n                x: this.startPoint.x - point.pageX,\r\n                y: this.startPoint.y - point.pageY,\r\n            }\r\n            if (!this.lockDirection) {\r\n                this.lockDirection = this._getLockDirection();\r\n                if (this.direction === 'y' && event.preventDefault) {\r\n                    event.preventDefault();\r\n                } \r\n            } else if (this.direction === this.lockDirection) {\r\n                event.preventDefault && event.preventDefault();\r\n                return Object.assign({x: 0, y: 0}, {[this.direction]: this.getMoveDist()})\r\n            }\r\n        }\r\n        // 如果return movePoint 那么位置不变\r\n        return this.endPoint;\r\n    }\r\n\r\n    end(): Point {\r\n        this.isAnm = false;\r\n        return this._getFinalEndPonit();\r\n    }\r\n\r\n}\r\n\r\nexport default MoveControl;\r\n"],"sourceRoot":""}