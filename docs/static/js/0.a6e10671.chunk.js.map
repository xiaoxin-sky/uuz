{"version":3,"sources":["controller/scroll.ts","views/Scroll.tsx","site/pages/scroll/index.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","controller/event.ts","controller/move.ts"],"names":["DistanceStatus","ScrollControl","direction","Refresh_Distance","distanceStatus","isRefreshable","this","EMPTY","x","y","tip","dist","getDist","DONE","HALF","MoveControl","Scroll","props","freshBoxClassName","refScrollArea","refScrollBody","eventControl","scrollControl","freshStore","Begin_Distance","End_Distance","oldDistance","bottleneck","beginTime","hideScrollTip","setState","transform","distance","time","updateScroll","freshHandler","scrollTip","setTimeout","getBottleneck","offsetHeight","onStartHandler","event","state","canRefresh","banRefresh","start","Date","now","onMoveHandler","preventDefault","distanceY","move","markScrollTip","finalDistance","newDistance","onEndHandler","status","getUpdateStatus","end","console","log","loadHandler","className","EventControl","createEventList","listenerAllOfEle","removeAllOfEle","ref","ele","style","transition","children","React","PureComponent","TestContent","Array","num","fill","map","val","idx","key","TestReFresh","useState","setNum","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","protoProps","staticProps","prototype","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_typeof2","obj","Symbol","iterator","constructor","_typeof","_possibleConstructorReturn","self","call","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","create","value","eventList","willPreventDefault","willNotPreventDefault","$ele","isPassiveSupported","passiveSupported","passive","touchstart","mousedown","touchmove","mousemove","touchend","mouseup","keys","forEach","pd","indexOf","addEventListener","removeEventListener","zeroPoint","JSON","stringify","startPoint","endPoint","Prevent_Distance","lockDirection","isAnm","parse","Error","absX","Math","abs","absY","cancelable","document","body","stopPropagation","point","getEventPoint","pageX","pageY","assign","_getLockDirection","_getFinalEndPonit"],"mappings":"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","file":"static/js/0.a6e10671.chunk.js","sourcesContent":["import MoveControl from './move';\n\ntype Point = {\n    x: number,\n    y: number\n}\n\nenum DistanceStatus { 'EMPTY', 'HALF', 'DONE' }\n\ntype Status = 'update' | 'reset' | 'none';\n\nclass ScrollControl extends MoveControl {\n    \n    Refresh_Distance: number;\n    distanceStatus?: DistanceStatus;\n    isRefreshable: boolean;\n\n    constructor() {\n        super({direction: 'y'});\n        this.Refresh_Distance = 90;\n        this.isRefreshable = true;\n    }\n\n    _getFinalEndPonit(): Point {\n        this.distanceStatus = DistanceStatus.EMPTY;\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n\n    banRefresh() {\n        this.isRefreshable = false;\n    }\n\n    canRefresh() {\n        this.isRefreshable = true;\n    }\n\n    markScrollTip(): string {\n        let tip = '';\n        const dist = this.getDist();\n        if (dist > this.Refresh_Distance) {\n            this.distanceStatus = DistanceStatus.DONE;\n            tip = '松开刷新';\n        } else if (dist > 0){\n            this.distanceStatus = DistanceStatus.HALF;\n            tip = '下拉刷新';\n        }\n        return tip;\n    }\n\n    getUpdateStatus(): Status {\n        if (this.distanceStatus === DistanceStatus.DONE) {\n            return 'update';\n        }\n        if (this.distanceStatus === DistanceStatus.HALF) {\n            return 'reset';\n        }\n        return 'none';\n    }\n\n}\n\nexport default ScrollControl;","import React from 'react';\nimport EventControl from '../controller/event';\nimport ScrollControl from '../controller/scroll';\n\ninterface ReScrollProps {\n  className?: String, // 刷新组件的 支持添加className\n  freshDistance?: number, // 触发刷新需要的：下拉距离\n  loadDistance?: number, // 触发加载需要的：距离最底部距离\n  freshHandler: Function | undefined, // 刷新执行的函数\n  loadHandler: Function | undefined // 加载执行的函数\n  children?: React.ReactNode\n}\n\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\nexport default  class Scroll extends React.PureComponent<ReScrollProps, any> {\n  freshBoxClassName: string;\n  refScrollArea?: HTMLDivElement | null;\n  refScrollBody?: HTMLDivElement | null;\n  eventControl?: EventControl;\n  scrollControl: ScrollControl;\n  freshStore: {[key: string]: Function};\n  Begin_Distance: number;\n  End_Distance: number;\n  oldDistance: number;\n  bottleneck: number;\n  beginTime: number;\n\n  constructor(props: ReScrollProps) {\n    super(props);\n    this.freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\n    this.Begin_Distance = -50;\n    this.End_Distance = 30;\n    this.scrollControl = new ScrollControl();\n    this.freshStore = {\n      'update': this.updateScroll,\n      'reset': this.hideScrollTip,\n      'none': () => {}\n    }\n    this.oldDistance = 0;\n    this.bottleneck = 0;\n    this.beginTime = 0;\n    // state\n    this.state = {\n      transform: {\n        distance: this.Begin_Distance,\n        time: 0\n      },\n      scrollTip: ''\n    }\n  }\n\n  hideScrollTip = (): void => {\n    this.setState({\n      transform: {\n        distance: this.Begin_Distance,\n        time: 0.5\n      }\n    })\n  }\n\n  updateScroll = () => {\n    this.props.freshHandler!();\n    this.setState({\n      scrollTip: '刷新完成>>>',\n      transform: {\n        distance: 0,\n        time: 2\n      }\n    })\n    setTimeout(() => {\n      this.hideScrollTip()\n    }, 300);\n  }\n\n  getBottleneck = () => {\n    const body = this.refScrollBody!.offsetHeight;\n    const box = this.refScrollArea!.offsetHeight;\n    return  body - box + this.Begin_Distance;\n  }\n\n  onStartHandler = (event: UseEvent): void => {\n    if (this.state.transform.distance === this.Begin_Distance) {\n      this.scrollControl.canRefresh()\n    } else {\n      this.scrollControl.banRefresh()\n    }\n    this.scrollControl.start(event);\n    this.oldDistance = this.state.transform.distance;\n    this.bottleneck = this.getBottleneck();\n    this.beginTime = Date.now();\n  }\n\n  onMoveHandler = (event: UseEvent) => {\n    event.preventDefault();\n    const point = this.scrollControl.move(event);\n    const distanceY = point.y;\n    // 下拉动画\n    if (distanceY > 0 && this.scrollControl.isRefreshable) {\n      const scrollTip = this.scrollControl.markScrollTip();\n      this.setState({\n        scrollTip\n      })\n    }\n    const newDistance = this.oldDistance + distanceY;\n    let finalDistance;\n    if (newDistance > this.Begin_Distance && !this.scrollControl.isRefreshable) {\n      // 顶点\n      finalDistance = this.Begin_Distance;\n    } else if (this.bottleneck <= (-newDistance)) {\n      // 终点\n      finalDistance = -this.bottleneck - this.End_Distance;\n    } else {\n      if (distanceY > 0) {\n        // 下拉刷新移动一半\n        finalDistance = this.oldDistance + distanceY/2;\n      } else {\n        finalDistance = newDistance;\n      }\n    }\n    this.setState({\n      transform: {\n        distance: finalDistance,\n        time: 0\n      }\n    })\n  }\n\n  onEndHandler = (): void => {\n    // 需要刷新的时候执行 传入的刷新方法\n    if (typeof this.props.freshHandler === 'function') {\n      const status = this.scrollControl.getUpdateStatus();\n      if (status !== 'none') {\n        this.freshStore[status]();\n        this.scrollControl.end();\n        return;\n      };\n    }\n\n    const endTime = Date.now();\n    const moveTime = endTime - this.beginTime;\n    console.log(this.oldDistance, this.state.transform.distance)\n\n    if (typeof this.props.loadHandler === 'function') {\n      if (this.bottleneck <= (-this.state.transform.distance)) {\n        this.props.loadHandler();\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.eventControl = new EventControl(this.refScrollArea!);\n    this.eventControl.createEventList(this.onStartHandler, this.onMoveHandler, this.onEndHandler);\n    this.eventControl.listenerAllOfEle();\n  }\n\n  componentWillUnmount() {\n    this.eventControl!.removeAllOfEle();\n  }\n  \n  render() {\n    return <div\n      className={this.freshBoxClassName}\n      ref={ele => this.refScrollArea = ele}>\n        {/* 滚动区域 */}\n        <div\n          className=\"zui-scroll-area\"\n          ref={ele => this.refScrollBody = ele}\n          style={{\n            transform: `translate(0, ${this.state.transform.distance}px)`,\n            transition: `transform ${this.state.transform.time}s`\n          }}\n        >\n          {/* 刷新tip */}\n          <div className=\"zui-scroll-tip\">{this.state.scrollTip}</div>\n          {/* 真正的内容 */}\n          <div className=\"zui-scroll\">\n            {this.props.children}\n          </div>\n          <div className=\"zui-scroll-load-tip\">加载更多内容</div>\n        </div>\n      </div>\n  }\n}\n\n// import React, { useState, useEffect, useRef } from 'react';\n// import EventControl from '../controller/event';\n// import ScrollControl from '../controller/scroll';\n\n// interface ReScrollProps {\n//   className?: String, // 刷新组件的 支持添加className\n//   freshDistance?: number, // 触发刷新需要的：下拉距离\n//   loadDistance?: number, // 触发加载需要的：距离最底部距离\n//   freshHandler: Function | undefined, // 刷新执行的函数\n//   loadHandler: Function | undefined // 加载执行的函数\n//   children?: React.ReactNode\n// }\n\n// type UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\n// export default function Scroll(props: ReScrollProps) {\n\n//   const Begin_Distance = -50;\n\n//   const [scrollTip, setScrollTip] = useState('');\n//   const [transform, setTransform] = useState({distance: Begin_Distance, time: 0});\n//   const [bottleneck, setBottleneck] = useState(0);\n//   const [scrollControl] = useState(new ScrollControl());\n//   const [bindFlag, setBindFlag] = useState(0);\n\n//   let refScrollArea: HTMLDivElement | null;\n//   let refScrollBody = useRef(null);\n\n//   let freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\n  \n//   const hideScrollTip = (): void => {\n//     setTransform({\n//       distance: Begin_Distance,\n//       time: 0.5\n//     })\n//   }\n  \n//   const updateScroll = () => {\n//     props.freshHandler!();\n//     setTransform({\n//       distance: 0,\n//       time: 2\n//     })\n//     setScrollTip('刷新中 >>>');\n//     setTimeout(() => {\n//       hideScrollTip()\n//       setBindFlag(bindFlag + 1);\n//     }, 300);\n//   }\n\n//   const freshStore = {\n//     'update': updateScroll,\n//     'reset': hideScrollTip,\n//     'none': () => {}\n//   }\n\n//   const onStartHandler = (event: UseEvent): void => {\n//     if (transform.distance === Begin_Distance) {\n//       scrollControl.canRefresh()\n//     } else {\n//       scrollControl.banRefresh()\n//     }\n//     scrollControl.start(event);\n//     console.log('开始')\n//   }\n\n//   const onMoveHandler = (event: UseEvent) => {\n//     event.preventDefault();\n//     const point = scrollControl.move(event);\n//     const distanceY = point.y;\n//     // 下拉动画\n//     if (distanceY > 0 && scrollControl.isRefreshable) {\n//       const tip = scrollControl.markScrollTip();\n//       setScrollTip(tip);\n//     }\n\n//     const newDistance = transform.distance + distanceY;\n//     if (newDistance > Begin_Distance && !scrollControl.isRefreshable) {\n//       setTransform({\n//         distance: Begin_Distance,\n//         time: 0\n//       })\n//     } else {\n//       setTransform({\n//         distance: transform.distance + distanceY,\n//         time: 0\n//       })\n//     }\n//   }\n\n//   const onEndHandler = (): void => {\n//     // 需要刷新的时候执行 传入的刷新方法\n//     if (typeof props.freshHandler === 'function') {\n//       const status = scrollControl.getUpdateStatus();\n//       if (status !== 'none') {\n//         freshStore[status]();\n//         scrollControl.end();\n//         return;\n//       };\n//     }\n\n//     if (typeof props.loadHandler === 'function') {\n//       const scrollEle = (refScrollBody.current as any);\n//       console.log(scrollEle.offsetHeight, bottleneck, (-transform.distance))\n//       if (scrollEle.offsetHeight <= bottleneck + (-transform.distance)) {\n//         props.loadHandler();\n//         setBindFlag(bindFlag + 1);\n//       }\n//     }\n//   }\n\n//   useEffect(() => {\n//     setBottleneck(refScrollArea!.offsetHeight);\n//     setBindFlag(bindFlag + 1);\n//   }, [])\n\n//   useEffect(() => {\n//     const eventControl = new EventControl(refScrollArea!);\n//     eventControl.createEventList(onStartHandler, onMoveHandler, onEndHandler);\n//     eventControl.listenerAllOfEle();\n//     return () => {\n//         eventControl.removeAllOfEle();\n//     }\n//   }, [bindFlag])\n\n//   return <div\n//     className={freshBoxClassName}\n//     ref={ele => refScrollArea = ele}>\n//       {/* 滚动区域 */}\n//       <div\n//         className=\"zui-scroll-area\"\n//         ref={refScrollBody}\n//         style={{\n//           transform: `translate(0, ${transform.distance}px)`,\n//           transition: `transform ${transform.time}s`\n//         }}\n//       >\n//         {/* 刷新tip */}\n//         <div className=\"zui-scroll-tip\">{scrollTip}</div>\n//         {/* 真正的内容 */}\n//         <div className=\"zui-scroll\">\n//           {props.children}\n//         </div>\n//       </div>\n//     </div>\n// }","import React, { useState } from 'react';\n\nimport Scroll from '../../../views/Scroll'\n\nfunction TestContent(props) {\n    return Array(props.num).fill(0).map((val, idx) => {\n        return <div className=\"test-content\" key={idx}>{idx + 1}：需用手机模式测试</div>\n    })\n}\n\nfunction TestReFresh() {\n\n    const [num, setNum] = useState(50);\n\n    const freshHandler = () => {\n        console.log('刷新')\n        setNum(50)\n    }\n\n    const loadHandler = () => {\n        console.log('加载')\n        setNum(num + 30);\n    }\n\n    return <Scroll\n        className=\"test-fresh\"\n        freshHandler={freshHandler}\n        loadHandler={loadHandler}>\n        <TestContent num={num}></TestContent>\n    </Scroll>\n}\n\nexport default TestReFresh;","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import { passiveSupported } from \"../utils/base\";\n\nclass EventControl {\n    \n    eventList: {[key: string]: Function};\n    willPreventDefault: object | boolean;\n    willNotPreventDefault: object | boolean;\n    $ele: HTMLDivElement;\n\n    constructor(ele: HTMLDivElement) {\n        this.eventList = {};\n        const isPassiveSupported = passiveSupported();\n        this.willPreventDefault = isPassiveSupported ? { passive: false } : false;\n        this.willNotPreventDefault = isPassiveSupported ? { passive: true } : false;\n        this.$ele = ele;\n    }\n\n    createEventList(start: Function, move: Function, end: Function) {\n        this.eventList =  {\n            touchstart: start,\n            mousedown: start,\n            touchmove: move,\n            mousemove: move,\n            touchend: end,\n            mouseup: end,\n        }\n    }\n\n    listenerAllOfEle() {\n        Object.keys(this.eventList).forEach(key => {\n            const pd = key.indexOf('move') >= 0 ? this.willPreventDefault : this.willNotPreventDefault;\n            this.$ele.addEventListener(key, this.eventList[key] as any, pd as any);\n        })\n    }\n\n    removeAllOfEle() {\n        Object.keys(this.eventList).forEach(key => {\n            this.$ele.removeEventListener(key, this.eventList[key] as any);\n        })\n    }\n}\n\nexport default EventControl;\n","import { getEventPoint } from \"../utils/base\";\nimport { passiveSupported } from \"../utils/base\";\n\ntype Point = {\n    x: number,\n    y: number\n}\n\ntype Direction = 'x' | 'y';\n\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\ninterface MoveControlProps {\n    direction?: Direction\n}\n\nconst zeroPoint = JSON.stringify({ x: 0, y: 0 });\n\nclass MoveControl {\n\n    startPoint: Point;\n    distance: Point;\n    endPoint: Point;\n    direction: Direction;\n    Prevent_Distance: number;\n    lockDirection: Direction | null;\n    isAnm: boolean;\n\n    constructor({direction = 'x'}: MoveControlProps) {\n        this.direction = direction;\n        this.startPoint = JSON.parse(zeroPoint);\n        this.distance = JSON.parse(zeroPoint);\n        this.endPoint = JSON.parse(zeroPoint);\n        this.Prevent_Distance = 5;\n        this.lockDirection = null;\n        this.isAnm = false;\n    }\n\n    // 终止时位置调整\n    _getFinalEndPonit(): Point {\n        throw Error('_getFinalEndPonit 需要被重写');\n    }\n\n    // 方向锁定\n    _getLockDirection(): Direction | null {\n        const absX = Math.abs(this.distance.x);\n        const absY = Math.abs(this.distance.y);\n\n        let lockDirection: Direction | null = null;\n\n        if (this.direction === 'x') {\n            if (absX >= absY && absX > this.Prevent_Distance) {\n                lockDirection = 'x';\n            } else if (absY > this.Prevent_Distance) {\n                lockDirection = 'y';\n            }\n        } else {\n            if (absY >= absX && absY > this.Prevent_Distance) {\n                lockDirection = 'y';\n            } else if (absX > this.Prevent_Distance) {\n                lockDirection = 'x';\n            }\n        }\n        \n        return lockDirection;\n    }\n\n    getDist() {\n        const dist = this.endPoint[this.direction] - this.distance[this.direction];\n        return dist;\n    }\n\n    preventDefault(event: UseEvent) {\n        if (event.cancelable) { // 是否可以取消默认事件\n            event.preventDefault();\n        }\n    }\n\n    freezeBody() {\n        const isPassiveSupported = passiveSupported();\n        const willPreventDefault = isPassiveSupported ? { passive: false } : false;\n        document.body.addEventListener('touchmove', (this.preventDefault as any), willPreventDefault);\n    }\n\n    unfreezeBody() {\n        document.body.removeEventListener('touchmove', (this.preventDefault as any));\n    }\n\n    start(event: UseEvent): void {\n        event.stopPropagation();\n        this.isAnm = true;\n        const point = getEventPoint(event);\n        this.lockDirection = null;\n        this.startPoint = {\n            x: point.pageX,\n            y: point.pageY\n        }\n    }\n\n    move(event: UseEvent): Point {\n        if (this.isAnm) {\n            event.stopPropagation();\n            const point = getEventPoint(event);\n            this.distance = {\n                x: this.startPoint.x - point.pageX,\n                y: this.startPoint.y - point.pageY,\n            }\n            if (!this.lockDirection) {\n                // if (event.cancelable) {\n                //     event.preventDefault();\n                // }\n                this.lockDirection = this._getLockDirection();\n            } else if (this.direction === this.lockDirection) {\n                if (event.cancelable) { // 是否可以取消默认事件\n                    event.preventDefault();\n                }\n                return Object.assign({x: 0, y: 0}, {[this.direction]: this.getDist()})\n            }\n        }\n        // 如果return movePoint 那么位置不变\n        return this.endPoint;\n    }\n\n    end(): Point {\n        this.isAnm = false;\n        return this._getFinalEndPonit();\n    }\n\n}\n\nexport default MoveControl;\n"],"sourceRoot":""}