{"version":3,"sources":["controller/scroll.ts","views/Scroll.tsx","site/pages/scroll/index.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","controller/event.ts","controller/move.ts"],"names":["DistanceStatus","ScrollControl","direction","Refresh_Distance","distanceStatus","isRefreshable","beginTime","x","y","this","_markBeginTime","distance","Date","now","getMoveDist","_getTimeTotal","EMPTY","tip","dist","DONE","HALF","MoveControl","Scroll","props","freshBoxClassName","refScrollWarp","refScrollBody","eventControl","scrollControl","freshStore","Begin_Distance","End_Distance","oldDistance","scrollBottleneck","hideScrollTip","setState","transform","time","updateScroll","freshHandler","scrollTip","setTimeout","getScrollBottleneck","offsetHeight","scrollMat","expectMat","getExpectMat","finalPonit","state","onStartHandler","event","start","isRefreshAble","setRefreshAble","onMoveHandler","preventDefault","distanceY","move","markScrollTip","finalDistance","newDistance","onEndHandler","end","status","getUpdateStatus","resetRefreshStatus","loadHandler","className","EventControl","createEventList","listenerAllOfEle","removeAllOfEle","ref","ele","style","transition","children","React","PureComponent","TestContent","Array","num","fill","map","val","idx","key","TestReFresh","useState","setNum","console","log","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","protoProps","staticProps","prototype","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_typeof2","obj","Symbol","iterator","constructor","_typeof","_possibleConstructorReturn","self","call","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","create","value","eventList","willPreventDefault","willNotPreventDefault","$ele","isPassiveSupported","passiveSupported","passive","window","touchstart","touchmove","touchend","mousedown","mousemove","mouseup","keys","forEach","pd","indexOf","addEventListener","removeEventListener","zeroPoint","JSON","stringify","startPoint","endPoint","Prevent_Distance","lockDirection","isAnm","parse","Error","absX","Math","abs","absY","point","getEventPoint","pageX","pageY","_resetSomething","assign","_getLockDirection","_getFinalEndPonit"],"mappings":"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","file":"static/js/1.d48193af.chunk.js","sourcesContent":["import MoveControl from './move';\n\ntype Point = {\n    x: number,\n    y: number\n}\n\nenum DistanceStatus { 'EMPTY', 'HALF', 'DONE' }\n\ntype Status = 'update' | 'reset' | 'none';\n\nclass ScrollControl extends MoveControl {\n    \n    Refresh_Distance: number;\n    distanceStatus?: DistanceStatus;\n    isRefreshable: boolean;\n    beginTime?: number;\n\n    constructor() {\n        super({direction: 'y'});\n        this.Refresh_Distance = 90;\n        this.isRefreshable = true;\n    }\n\n    _getFinalEndPonit(): Point {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n\n    _resetSomething() {\n        this._markBeginTime();\n        this.distance[this.direction] = 0;\n    }\n\n    _markBeginTime() {\n        this.beginTime = Date.now();\n    }\n\n    _getTimeTotal(): number {\n        const endTime = Date.now();\n        const moveTime = endTime - this.beginTime!;\n        return moveTime;\n    }\n\n    getExpectMat(): number {\n        const distanceTotal = this.getMoveDist();\n        const moveTime = this._getTimeTotal();\n        // 速度 = 路程 / 时间\n        const speed = distanceTotal / moveTime;\n        // 计算期望缓冲距离\n        const mat = speed * 234;\n        return mat;\n    }\n\n    setRefreshAble(isRefreshable: boolean) {\n        this.isRefreshable = isRefreshable;\n    }\n\n    resetRefreshStatus() {\n        this.distanceStatus = DistanceStatus.EMPTY;\n    }\n\n    markScrollTip(): string {\n        let tip = '';\n        const dist = this.getMoveDist();\n        if (dist > this.Refresh_Distance) {\n            this.distanceStatus = DistanceStatus.DONE;\n            tip = '松开刷新';\n        } else if (dist > 0){\n            this.distanceStatus = DistanceStatus.HALF;\n            tip = '下拉刷新';\n        }\n        return tip;\n    }\n\n    getUpdateStatus(): Status {\n        if (this.distanceStatus === DistanceStatus.DONE) {\n            return 'update';\n        }\n        if (this.distanceStatus === DistanceStatus.HALF) {\n            return 'reset';\n        }\n        return 'none';\n    }\n\n}\n\nexport default ScrollControl;","import React from 'react';\nimport EventControl from '../controller/event';\nimport ScrollControl from '../controller/scroll';\n\ninterface ReScrollProps {\n  className?: String, // 刷新组件的 支持添加className\n  freshDistance?: number, // 触发刷新需要的：下拉距离\n  loadDistance?: number, // 触发加载需要的：距离最底部距离\n  freshHandler: Function | undefined, // 刷新执行的函数\n  loadHandler: Function | undefined // 加载执行的函数\n  children?: React.ReactNode\n}\n\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\nexport default  class Scroll extends React.PureComponent<ReScrollProps, any> {\n  freshBoxClassName: string;\n  refScrollWarp?: HTMLDivElement | null;\n  refScrollBody?: HTMLDivElement | null;\n  eventControl?: EventControl;\n  scrollControl: ScrollControl;\n  freshStore: {[key: string]: Function};\n  Begin_Distance: number;\n  End_Distance: number;\n  oldDistance: number;\n  scrollBottleneck: number;\n  // scrolling: boolean;\n\n  constructor(props: ReScrollProps) {\n    super(props);\n    this.freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\n    this.Begin_Distance = -50;\n    this.End_Distance = 26;\n    this.scrollControl = new ScrollControl(); // 滚动控制器只返回距离和状态，不操作dom\n    this.freshStore = {\n      'update': this.updateScroll,\n      'reset': this.hideScrollTip,\n      'none': () => {}\n    }\n    this.oldDistance = 0;\n    this.scrollBottleneck = 0;\n    // this.scrolling = false\n    // state\n    this.state = {\n      transform: {\n        distance: this.Begin_Distance,\n        time: 0\n      },\n      scrollTip: ''\n    }\n  }\n\n  hideScrollTip = (): void => {\n    this.setState({\n      transform: {\n        distance: this.Begin_Distance,\n        time: 0.5\n      }\n    })\n  }\n\n  updateScroll = () => {\n    this.props.freshHandler!();\n    // this.scrolling = true;\n    this.setState({\n      scrollTip: '刷新完成>>>',\n      transform: {\n        distance: 0,\n        time: 2\n      }\n    })\n    setTimeout(() => {\n      this.hideScrollTip()\n    }, 300);\n  }\n\n  // 可滚动距离\n  getScrollBottleneck = () => {\n    const body = this.refScrollBody!.offsetHeight;\n    const box = this.refScrollWarp!.offsetHeight;\n    return  body - box + this.Begin_Distance;\n  }\n\n  //  滚动缓冲\n  scrollMat = () => {\n    const expectMat = this.scrollControl.getExpectMat();\n    if (expectMat) {\n      // this.scrolling = true;\n      let finalPonit = this.state.transform.distance + expectMat;\n      if (finalPonit > this.Begin_Distance) {\n        // 不能低于起点\n        finalPonit = this.Begin_Distance\n      } else if (finalPonit < -this.scrollBottleneck) {\n        // 不能超过终点\n        finalPonit = -this.scrollBottleneck;\n      }\n      this.setState({\n        transform: {\n          distance: finalPonit,\n          time: 0.5\n        }\n      })\n    }\n  }\n\n  onStartHandler = (event: UseEvent): void => {\n    this.setState({\n      transform: {\n        distance: this.state.transform.distance,\n        time: 0\n      }\n    })\n    this.scrollControl.start(event);\n    const isRefreshAble = this.state.transform.distance === this.Begin_Distance;\n    this.scrollControl.setRefreshAble(isRefreshAble);\n    \n    this.oldDistance = this.state.transform.distance;\n    this.scrollBottleneck = this.getScrollBottleneck();\n  }\n\n  onMoveHandler = (event: UseEvent) => {\n    event.preventDefault();\n    const point = this.scrollControl.move(event);\n    const distanceY = point.y;\n    // 下拉动画\n    if (distanceY > 0 && this.scrollControl.isRefreshable) {\n      const scrollTip = this.scrollControl.markScrollTip();\n      this.setState({ scrollTip })\n    }\n    const newDistance = this.oldDistance + distanceY;\n    let finalDistance;\n    if (!this.scrollControl.isRefreshable &&\n        newDistance > this.Begin_Distance) { // 顶点\n      finalDistance = this.Begin_Distance;\n    } else if (this.scrollBottleneck <= (-newDistance)) { // 终点\n      finalDistance = -this.scrollBottleneck - this.End_Distance;\n    } else {\n      if (distanceY > 0) { // 下拉刷新移动一半\n        finalDistance = this.oldDistance + distanceY/2;\n      } else {\n        finalDistance = newDistance;\n      }\n    }\n    this.setState({\n      transform: {\n        distance: finalDistance,\n        time: 0\n      }\n    })\n  }\n\n  onEndHandler = (): void => {\n    this.scrollControl.end();\n    // 需要刷新的时候执行 传入的刷新方法\n    if (typeof this.props.freshHandler === 'function') {\n      const status = this.scrollControl.getUpdateStatus();\n      if (status !== 'none') {\n        this.freshStore[status]();\n        this.scrollControl.resetRefreshStatus();\n        return;\n      };\n    }\n\n    // 滚动缓冲\n    this.scrollMat();\n\n    if (typeof this.props.loadHandler === 'function') {\n      if (this.scrollBottleneck <= (-this.state.transform.distance)) {\n        this.props.loadHandler();\n      }\n    }\n  }\n\n  // transitionEndHandler = () => {\n  //   this.scrolling = false;\n  // }\n\n  componentDidMount() {\n    this.eventControl = new EventControl(this.refScrollWarp!);\n    this.eventControl.createEventList(this.onStartHandler, this.onMoveHandler, this.onEndHandler);\n    this.eventControl.listenerAllOfEle();\n  }\n\n  componentWillUnmount() {\n    this.eventControl!.removeAllOfEle();\n  }\n  \n  render() {\n    return <div\n      className={this.freshBoxClassName}\n      // onTransitionEnd={this.transitionEndHandler}\n      ref={ele => this.refScrollWarp = ele}>\n        {/* 滚动区域 */}\n        <div\n          className=\"zui-scroll-area\"\n          ref={ele => this.refScrollBody = ele}\n          style={{\n            transform: `translate(0, ${this.state.transform.distance}px)`,\n            transition: `transform ${this.state.transform.time}s`\n          }}\n        >\n          {/* 刷新tip */}\n          <div className=\"zui-scroll-tip\">{this.state.scrollTip}</div>\n          {/* 真正的内容 */}\n          <div className=\"zui-scroll\">\n            {this.props.children}\n          </div>\n          <div className=\"zui-scroll-load-tip\">加载更多内容</div>\n        </div>\n      </div>\n  }\n}\n\n// import React, { useState, useEffect, useRef } from 'react';\n// import EventControl from '../controller/event';\n// import ScrollControl from '../controller/scroll';\n\n// interface ReScrollProps {\n//   className?: String, // 刷新组件的 支持添加className\n//   freshDistance?: number, // 触发刷新需要的：下拉距离\n//   loadDistance?: number, // 触发加载需要的：距离最底部距离\n//   freshHandler: Function | undefined, // 刷新执行的函数\n//   loadHandler: Function | undefined // 加载执行的函数\n//   children?: React.ReactNode\n// }\n\n// type UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\n// export default function Scroll(props: ReScrollProps) {\n\n//   const Begin_Distance = -50;\n\n//   const [scrollTip, setScrollTip] = useState('');\n//   const [transform, setTransform] = useState({distance: Begin_Distance, time: 0});\n//   const [scrollBottleneck, setScrollBottleneck] = useState(0);\n//   const [scrollControl] = useState(new ScrollControl());\n//   const [bindFlag, setBindFlag] = useState(0);\n\n//   let refScrollWarp: HTMLDivElement | null;\n//   let refScrollBody = useRef(null);\n\n//   let freshBoxClassName = `zui-scroll-box ${props.className || ''}`;\n  \n//   const hideScrollTip = (): void => {\n//     setTransform({\n//       distance: Begin_Distance,\n//       time: 0.5\n//     })\n//   }\n  \n//   const updateScroll = () => {\n//     props.freshHandler!();\n//     setTransform({\n//       distance: 0,\n//       time: 2\n//     })\n//     setScrollTip('刷新中 >>>');\n//     setTimeout(() => {\n//       hideScrollTip()\n//       setBindFlag(bindFlag + 1);\n//     }, 300);\n//   }\n\n//   const freshStore = {\n//     'update': updateScroll,\n//     'reset': hideScrollTip,\n//     'none': () => {}\n//   }\n\n//   const onStartHandler = (event: UseEvent): void => {\n//     if (transform.distance === Begin_Distance) {\n//       scrollControl.canRefresh()\n//     } else {\n//       scrollControl.banRefresh()\n//     }\n//     scrollControl.start(event);\n//     console.log('开始')\n//   }\n\n//   const onMoveHandler = (event: UseEvent) => {\n//     event.preventDefault();\n//     const point = scrollControl.move(event);\n//     const distanceY = point.y;\n//     // 下拉动画\n//     if (distanceY > 0 && scrollControl.isRefreshable) {\n//       const tip = scrollControl.markScrollTip();\n//       setScrollTip(tip);\n//     }\n\n//     const newDistance = transform.distance + distanceY;\n//     if (newDistance > Begin_Distance && !scrollControl.isRefreshable) {\n//       setTransform({\n//         distance: Begin_Distance,\n//         time: 0\n//       })\n//     } else {\n//       setTransform({\n//         distance: transform.distance + distanceY,\n//         time: 0\n//       })\n//     }\n//   }\n\n//   const onEndHandler = (): void => {\n//     // 需要刷新的时候执行 传入的刷新方法\n//     if (typeof props.freshHandler === 'function') {\n//       const status = scrollControl.getUpdateStatus();\n//       if (status !== 'none') {\n//         freshStore[status]();\n//         scrollControl.end();\n//         return;\n//       };\n//     }\n\n//     if (typeof props.loadHandler === 'function') {\n//       const scrollEle = (refScrollBody.current as any);\n//       console.log(scrollEle.offsetHeight, scrollBottleneck, (-transform.distance))\n//       if (scrollEle.offsetHeight <= scrollBottleneck + (-transform.distance)) {\n//         props.loadHandler();\n//         setBindFlag(bindFlag + 1);\n//       }\n//     }\n//   }\n\n//   useEffect(() => {\n//     setScrollBottleneck(refScrollWarp!.offsetHeight);\n//     setBindFlag(bindFlag + 1);\n//   }, [])\n\n//   useEffect(() => {\n//     const eventControl = new EventControl(refScrollWarp!);\n//     eventControl.createEventList(onStartHandler, onMoveHandler, onEndHandler);\n//     eventControl.listenerAllOfEle();\n//     return () => {\n//         eventControl.removeAllOfEle();\n//     }\n//   }, [bindFlag])\n\n//   return <div\n//     className={freshBoxClassName}\n//     ref={ele => refScrollWarp = ele}>\n//       {/* 滚动区域 */}\n//       <div\n//         className=\"zui-scroll-area\"\n//         ref={refScrollBody}\n//         style={{\n//           transform: `translate(0, ${transform.distance}px)`,\n//           transition: `transform ${transform.time}s`\n//         }}\n//       >\n//         {/* 刷新tip */}\n//         <div className=\"zui-scroll-tip\">{scrollTip}</div>\n//         {/* 真正的内容 */}\n//         <div className=\"zui-scroll\">\n//           {props.children}\n//         </div>\n//       </div>\n//     </div>\n// }","import React, { useState } from 'react';\n\nimport Scroll from '../../../views/Scroll'\n\nfunction TestContent(props) {\n    return Array(props.num).fill(0).map((val, idx) => {\n        return <div className=\"test-content\" key={idx}>{idx + 1}：需用手机模式测试</div>\n    })\n}\n\nfunction TestReFresh() {\n\n    const [num, setNum] = useState(50);\n\n    const freshHandler = () => {\n        console.log('刷新')\n        setNum(50)\n    }\n\n    const loadHandler = () => {\n        console.log('加载')\n        setNum(num + 30);\n    }\n\n    return <Scroll\n        className=\"test-fresh\"\n        freshHandler={freshHandler}\n        loadHandler={loadHandler}>\n        <TestContent num={num}></TestContent>\n    </Scroll>\n}\n\nexport default TestReFresh;","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import { passiveSupported } from \"../utils/base\";\n\nclass EventControl {\n    \n    eventList: {[key: string]: Function};\n    willPreventDefault: object | boolean;\n    willNotPreventDefault: object | boolean;\n    $ele: HTMLDivElement;\n\n    constructor(ele: HTMLDivElement) {\n        this.eventList = {};\n        const isPassiveSupported = passiveSupported();\n        this.willPreventDefault = isPassiveSupported ? { passive: false } : false;\n        this.willNotPreventDefault = isPassiveSupported ? { passive: true } : false;\n        this.$ele = ele;\n    }\n\n    createEventList(start: Function, move: Function, end: Function) {\n        if ('ontouchstart' in window) {\n            this.eventList =  {\n                touchstart: start,\n                touchmove: move,\n                touchend: end,\n            }\n        } else {\n            this.eventList =  {\n                mousedown: start,\n                mousemove: move,\n                mouseup: end,\n            }\n        }\n    }\n\n    listenerAllOfEle() {\n        Object.keys(this.eventList).forEach(key => {\n            const pd = key.indexOf('move') >= 0 ? this.willPreventDefault : this.willNotPreventDefault;\n            this.$ele.addEventListener(key, this.eventList[key] as any, pd as any);\n        })\n    }\n\n    removeAllOfEle() {\n        Object.keys(this.eventList).forEach(key => {\n            this.$ele.removeEventListener(key, this.eventList[key] as any);\n        })\n    }\n}\n\nexport default EventControl;\n","import { getEventPoint } from \"../utils/base\";\nimport { passiveSupported } from \"../utils/base\";\n\ntype Point = {\n    x: number,\n    y: number\n}\n\ntype Direction = 'x' | 'y';\n\ntype UseEvent = React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>;\n\ninterface MoveControlProps {\n    direction?: Direction\n}\n\nconst zeroPoint = JSON.stringify({ x: 0, y: 0 });\n\nclass MoveControl {\n\n    startPoint: Point;\n    distance: Point;\n    endPoint: Point;\n    direction: Direction;\n    Prevent_Distance: number;\n    lockDirection: Direction | null;\n    isAnm: boolean;\n\n    constructor({direction = 'x'}: MoveControlProps) {\n        this.direction = direction;\n        this.startPoint = JSON.parse(zeroPoint);\n        this.distance = JSON.parse(zeroPoint);\n        this.endPoint = JSON.parse(zeroPoint);\n        this.Prevent_Distance = 5;\n        this.lockDirection = null;\n        this.isAnm = false;\n    }\n\n    // 终止时位置调整\n    _getFinalEndPonit(): Point {\n        throw Error('_getFinalEndPonit 需要被重写');\n    }\n\n    // 起点重置项\n    _resetSomething() {\n        // 需要时重写\n        this.distance[this.direction] = 0;\n    }\n\n    // 方向锁定\n    _getLockDirection(): Direction | null {\n        const absX = Math.abs(this.distance.x);\n        const absY = Math.abs(this.distance.y);\n\n        let lockDirection: Direction | null = null;\n\n        if (this.direction === 'x') {\n            if (absX >= absY && absX > this.Prevent_Distance) {\n                lockDirection = 'x';\n            } else if (absY > this.Prevent_Distance) {\n                lockDirection = 'y';\n            }\n        } else {\n            if (absY >= absX && absY > this.Prevent_Distance) {\n                lockDirection = 'y';\n            } else if (absX > this.Prevent_Distance) {\n                lockDirection = 'x';\n            }\n        }\n        \n        return lockDirection;\n    }\n\n    // 移动过程中的移动距离 = 最后停留点 - 触摸点移动距离\n    getMoveDist() {\n        const dist = this.endPoint[this.direction] - this.distance[this.direction];\n        return dist;\n    }\n\n    start(event: UseEvent): void {\n        this.isAnm = true;\n        const point = getEventPoint(event);\n        this.lockDirection = null;\n        this.startPoint = {\n            x: point.pageX,\n            y: point.pageY\n        }\n        this._resetSomething();\n    }\n\n    // 移动时：获取移动距离\n    move(event: UseEvent): Point {\n        if (this.isAnm) {\n            const point = getEventPoint(event);\n            this.distance = {\n                x: this.startPoint.x - point.pageX,\n                y: this.startPoint.y - point.pageY,\n            }\n            if (!this.lockDirection) {\n                this.lockDirection = this._getLockDirection();\n                if (this.direction === 'y' && event.preventDefault) {\n                    event.preventDefault();\n                } \n            } else if (this.direction === this.lockDirection) {\n                event.preventDefault && event.preventDefault();\n                return Object.assign({x: 0, y: 0}, {[this.direction]: this.getMoveDist()})\n            }\n        }\n        // 如果return movePoint 那么位置不变\n        return this.endPoint;\n    }\n\n    end(): Point {\n        this.isAnm = false;\n        return this._getFinalEndPonit();\n    }\n\n}\n\nexport default MoveControl;\n"],"sourceRoot":""}